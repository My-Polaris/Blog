---
title: 算法入门一
date: 2020-05-19 12:26:44
tags: 算法
---

**时间、空间复杂度；**

**枚举(前缀和、差分、离散化、尺取法、二进制枚举)，位运算基础、贪心(大数乘除法)。**

<!--more-->

## 一.时间复杂度的介绍

​	时间复杂度一般都会用到大O表示法，如O（n）。这里我们首先其实是要把n看成一个无穷大的数，所以会忽略低阶以及常数，比如``O(n)=O(Cn)=O(Cn+C)``,``O(n^2+n)=O(n^2)``(近似等于),冒泡排序就是O(n^2)的一个经典例。

​	**所以一般看时间复杂度，只需要看循环次数，再干掉低阶和常数项。**

下面是一张时间复杂度的排序表，从上到下逐渐复杂。

<img src="算法入门一\时间复杂度排序.png" style="zoom:40%;" />

## 二.空间复杂度

​	1.由于计算机存储实数的方式是通过不断乘2并以二进制存的，有些实数天然存着就会损失精度，如0.3.

​	因此，**一般判断实数间是否相等的时候用的是fab(a-b)<=e-9或e-6**。(即允许有一点误差)

​	2.在编程题中，一般对于空间的要求会是内存<512M,经过换算之后，也就是说**最多只能开e+8的int数组**，否则就有风险造成空间超载而报错。

## 三、枚举

##### 1.引入题目1(前缀和)：<img src="算法入门一\数列求和问题.png" style="zoom:50%;" />

暴力解决思路：每次询问都对指定区域进行循环求和，由于查q次，每次查n个数，如果他有样例让你每次都从头查到尾，对应的最大时间复杂度为**O(n*q)**，我想运行超时是跑不了了。

正确解题思路：运用**前缀和**的基础算法思路。对应的时间复杂度为**O(n+p)**

​	前缀和：定义一个sum数组，**每个数组元素存放的是此前的所有元素的和**，即``sum[i]=sum[i-1]+a[i];``这样如果需要求区间的和，只需要用``sum[ri]-sum[li-1]``即可。(用li-1是因为求和中要包括a[li]这一元素)。

> 小tips：前缀和要考虑是否要使用long long型，免得数据太大int装不下。

​	每次查询只需要执行一条语句一次，爱了吗。

##### 2.引入题目2(差分)：<img src="D:算法入门一\数列修改问题.png" style="zoom:50%;" />

暴力解决思路：同样是枚举li到ri，为他们一个一个加上k，对应的最大时间复杂度为**O(n*q)**。

正确解题思路：运用**差分**的基础算法思路。将``每次要改变一个区间的值``改为``每次只改变两个端点的值``,对应时间复杂度为**O(n+q)**。

​	差分：**用数组delta[i]来维护第i个数与前一个数的差值**，即``delta[li]=delta[li]+k;  delta[ri+1]=delta[ri+1]-k;``

此时虽然只改变了两个端点的值，但在所有修改完成后，再**求前缀和**``a[i]=a[i-1]+delta[i]``，这样此时的a[i]就是所对应的每个元素的值了。(这里需要注意当i==0时，a[i]=0+delta[i])

​	**说到底前缀和与差分就是创建了有功能的数组，通过建立该数组与原数组的关系从而实现功能。**

​	**需要注意的是前缀和差分的操作是对称的，对差分求前缀和、对前缀和求差分 都会得到原数组。**

##### **3**.引入题目3(前缀和,差分,离散化):<img src="算法入门一\校门外的树.png" style="zoom:50%;" />

a.<img src="算法入门一\校门外的树1.png" style="zoom:50%;" />

​	数据不大，直接每次暴力循环li到ri，将对应的数组元素赋值为0(即将树挖走)。最后再计数依旧为1的数组元素个数即可。

```c++
#include<iostream>
using namespace std;
int main()
{
    int L,M;
    int sum=0;
    int a[10010]={'\0'};
    cin>>L>>M;
    for(int i=0;i<=L;i++)	a[i]=1;
    while(M--)
    {
        int l,r;
        cin>>l>>r;
        for(int i=l;i<=r;i++)
            a[i]=0;
    }
    for(int i=0;i<=L;i++)
        if(a[i]==1)    sum++;
    cout<<sum<<endl;
}
```



b.<img src="算法入门一\校门外的树2.png" style="zoom:50%;" />

​	为防止运行超时，不能暴力解了。

​	此时同样是差分的思路，左端点``delta[li]=delta[li]-1;``右端点``delta[ri+1]=delta[ri+1]+1;``读完M次数据后再求前缀和``a[i]=delta[i]+a[i-1]``。

​	需要注意的是，当i==0时的特例执行代码为``a[i]=1+delta[i];``

```c++
#include<iostream>
using namespace std;
int delta[10010];
int main()
{
    int L,M;
    int sum=0;
    int a[10010]={'\0'};
    cin>>L>>M;
    for(int i=0;i<=L;i++)	delta[i]=0;
    for(int i=0;i<=L;i++)	a[i]=1;
    while(M--)
    {
        int l,r;
        cin>>l>>r;
        delta[l]=delta[l]-1;
        delta[r+1]=delta[r+1]+1;
    }
    for(int i=0;i<=L;i++)
    {
		if(i==0)	a[i]=1+delta[i];//a[0-1]是1，如果delta[0]被改成了-1，则第一颗树也会被砍	
		else	a[i]=a[i-1]+delta[i];
	 } 
    	
    for(int i=0;i<=L;i++)
        if(a[i]==1)    sum++;
    cout<<sum<<endl;
}
```



c.<img src="算法入门一\校门外的树3.png" style="zoom:50%;" />

​	L来到e+9了，前面说过一般数组只能建到e+8，这就麻烦了。

​	因为M的取值范围依旧没变，此时可以用到**离散化**的概念。

​	离散化：**把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率**，此时的无限空间指的就是L，有限个体指的就是M。

题址：https://ac.nowcoder.com/acm/problem/24636

```c++
#include<bits/stdc++.h>
using namespace std;//L是1e9,M是1e5,离散化的时候数组大小只由区间个数1e5决定 
const int maxn=1e6+10;
struct P{
	long long s,e;
}p[maxn];
bool cmp(P a,P b){
	if(a.s==b.s)	return a.e<b.e;//相同开头,结尾越前排越前 
	return a.s<b.s;//开头越前排越前 
}
int main()
{
	int L,M;scanf("%d %d",&L,&M);//用scanf降低时间复杂度，用cin过不了，实在不行还能用自定义read()读取 
	for(int i=1;i<=M;i++)
		cin>>p[i].s>>p[i].e;//读取左右区间并存储
	sort(p+1,p+M+1,cmp);//排序
	int cnt=p[1].e-p[1].s+1,end=p[1].e;//cnt计数，end维护终点
	for(int i=2;i<=M;i++)
	{
		if(p[i].s<end && p[i].e>end){//情况1：上一区间与这一区间交错 
			cnt+=p[i].e-end;
			end=p[i].e;
		}
		else if(p[i].s>end){//情况2：整个区间在上一区间后头 
			cnt+=p[i].e-p[i].s+1;
		}//情况3：上一区间包含此区间，此情况无操作 
	}
	cout<<L+1-cnt<<endl; 
} 
```

##### **4**.引入题目4(尺取法)：<img src="算法入门一\尺取法.png" style="zoom:50%;" />

一般的暴力解：两条指针，挨个枚举，然后找出min输出，算法复杂度应该是O(n^2)

**尺取法(追逐法)求解:依旧利用前缀和，然后用R-L，如果>s,右指针停下，左指针右移；否则右指针继续右移**。这样计算实际上就是左右指针各走一遍n数组，算法复杂度为:O(2n)即O(n)。

例题：https://ac.nowcoder.com/acm/problem/107658。

##### 5.引入题目5(二进制枚举,DFS)：<img src="算法入门一\灯泡灭灭灭.png" style="zoom:50%;" />

这题算是思路题吧，一开始看到题的时候，我是完全不知道怎么解的。

主要还是要从枚举的思路入门，首先想象有这么个表格，10行100列，先直接枚举：只操作第一列而能把第一列所有灯关了的情况，(这里可以用**01串**表示每行的开关灯情况)，然后枚举操作第一列的方式，第二列要负责把第一列没关的关了，第三列关第二列的，类推，最后一列没人关了，只能自己关自己。

也就是说，这一列的开关方式取决于上一列，如果最后一列是全关的，那代表第一列的开关灯情况是对的，否则则是错的，得再次枚举。

这里01串的实现方式要用到位运算，即直接循环十进制数字，然后运用其对应的二进制数字来表示01串，从而表示各行的开关灯情况。（这个01串会在后续的状态压缩dp等算法里再次用到）

具体的实现方案：好难orz。

**类似题的题址：[POJ-1753 Flip Game ](https://vjudge.net/problem/POJ-1753)**

大致要求是：对于4X4的黑白棋方格，求让其翻转为全黑或全白的最小步数(翻转一个棋要同时翻转其上下左右的棋)。

输入：给出黑白棋方格的黑白棋摆布，'b'是黑,'w'是白。

解法一：二进制枚举。(也是位运算基础的内容)

```c++
#include <bits/stdc++.h>//c++万能头文件,有些OJ用不了
using namespace std;
#define N 10
#define M 100
int a[N],b[N];//前者为N行的白色01串(即是白色的就为1)，后者为黑色01串(即是黑色的就为1) 
int c[N];//用于表示处理之后N行的翻转情况，好让下一行知道如何处理
int ans=0x3f3f3f3f;//这里的16进制数比作无穷大 
int num[M];//十进制数字对应的执行翻转数，如5是0101,翻转次数为2。简单来说就是用于计算步数。

int get_num(int temp)
{
	int res=0;
	while(temp)//只要temp不是0，就继续执行
	{
		if(temp & 1)//判断temp二进制的末位是不是1，是1的时候返回ture，不是则返回false
			 res++;//计数
		temp>>=1; 
	} 
	return res;
}

void deal(int d[])//寻找让d这个01串变为00串的方案 
{
	for(int i=0;i<(1<<4);i++)//为第一行枚举共16种方案
	{
		/*第一行的翻转*/ 
		int sum=num[i];//先记下该翻转方案第一行的执行翻转数 
		c[1]=d[1]^i^((i<<1) & 0xf)^(i>>1);//这里运用到了^的性质，很精髓。
         c[2]=d[2]^i;
         //d[i]对应的是本身那一行的01串，而i则是翻转方案。
         //本质：对1翻转的时候(1^1=0)会把颜色反转，对0翻转的时候(0^1=1)也会把颜色反转。
         //即无论对象的颜色，1^对象都会使对象变色，翻转方案^01串就能起到翻转的作用
		//执行：把翻转方案里的1翻转，又把1的左、右边翻转(i<<1)(i>>1),下边翻转(c[2]=d[2]^i)
		//这里要注意的是(i<<1)的时候1可能会出现在第5位，这个时候会干扰运算，所以要与000001111进行与'&'运算(两个1才能是1) ，留下最多四个1。
		/*剩下的翻转都已经定下来了*/
		for(int j=2;j<=4;j++)//这里要把c[j-1]作为翻转方案
		{	
			sum=sum+num[c[j-1]];//这里要加上翻转方案c[j-1]的执行翻转数 
			c[j]=c[j]^c[j-1]^((c[j-1]<<1) & 0xf)^(c[j-1]>>1); //这里又很精髓。
            //把c[j-1]作为翻转方案是因为：上面的1必须由下面的1来消除（所以上面是1，下面的翻转方案的对应格就得是1）,上面的0的下面一定不能是1 (上面是0下面就得是0)
			c[j+1]=d[j+1]^c[j-1];
		}
		if(c[4]==0)//如果最后一行全是0了,victory
			ans = min(ans, sum);//记下步数少的
	}
}
int main()
{
	for(int i=0;i<(1<<4);i++)//用对应的二进制去枚举各种01串，如1=0001,2=0010。
		num[i]=get_num(i);//统计每种翻转方案的翻转次数
	for(int i=1;i<=4;i++)//针对黑白格局制造黑色01串和白色01串
	{
		for(int j=3;j>=0;j--)
		{
			char c;
			cin>>c;
			if(c=='b')	a[i] |= (1<<j);//每四个c出一次成效，会用01串表示对应的黑白情况，白色为1,黑色为0
			else	b[i]|=(1<<j);//黑色为1，白色为0		这里是运用了|的性质，留1
		}
	}
	deal(a);
	deal(b);
	if(ans>16)//大于16就代表没方案了
		cout<<"Impossible"<<endl;
	else
		cout<<ans<<endl;
	return 0;	
} 
```

解法二：DFS(暴力)，比上一种好理解多了。

```c++
#include <string>
#include <iostream>
//暴力的思路就比较简单了，直接通过深度搜索去搜索每个空翻与不翻的情况 
using namespace std;
bool map[5][5];//二维地图布尔数组 
int nextx[5]={1,-1,0,0,0};
int nexty[5]={0,0,0,-1,1};
int ans=0x3f3f3f;
bool check()//判断是否统一颜色 
{
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++)
			if(map[i][j]!=map[0][0])	return false;
	return true;
}
void turn(int x,int y)
{
	for(int i=0;i<5;i++)//最多翻五次，上下左右中
	{
		int X=x+nextx[i];
		int Y=y+nexty[i];
		if(X>=4||Y>=4||X<0||Y<0)	continue;
		map[X][Y]=!map[X][Y];
	} 
}
void dfs(int x,int y,int cnt)
{
	int X,Y;//下一条路的路标,注意的是如果用map[X][Y]访问的话，则是以[0][0],[1][0],[2][0]的顺序去遍历的 
	X=(x+1)%4;Y=y+(x+1)/4;//通过不断x+1来遍历地图，当x=3的时候会再回到0，同时y会+1
	if(check()){
		ans=min(ans,cnt);return ;//成功就返回。做到了全翻也会return;这就是深度搜索，要么走到终点，要么撞墙 
	}
	if(y>=4)		return ;//撞墙就返回。注意！这里为什么要写在check后面呢，是因为需要在dfs(0,4)去判断dfs(3,3)需不需要翻。 
	turn(x,y);dfs(X,Y,cnt+1);turn(x,y);//这一个空尝试着翻, 尝试完我得再翻回来进行别的尝试
	dfs(X,Y,cnt);//这一个空尝试着不翻
	return;
}
int main()
{
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++)
		{
			char a;cin>>a;	
			if(a=='w')	map[i][j]=true;
			else	map[i][j]=false;
		}
	dfs(0,0,0);
	if(ans>16)	cout<<"Impossible"<<endl;
	else	cout<<ans<<endl;
} 
```



## 四、位运算基础

1.在面对``a*2``时用``a<<1``表示可以运行得更快，``a/2``时用``a>>1``更快，好吧其实用来装x也是不错的。

2.``&``换位'与'运算，有一个0就是0（不是两个1就是0）

3.``|``换位'或'运算，有一个1就是1

4.``~``取反符，1变0,0变1，优先级高。（十进制数字-1取反会得到0）

5.补码：其实就是取反之后再+1

6.异或``^``运算：俩数不同则出1，俩数相同则出0，也可以理解为两个二进制的数字各个位分别相加，但是会把进的位吃掉(如1+1=0,满2进位，进的位被我吃了)。

7.巧妙利用异或运算符做到：不建立第三个变量而达到a,b交换。

```c++
a=a^b;		//a'=a^b;
b=a^b;		//b'=a'^b=a^b^b=a;
a=a^b;		//a''=a'^b'=a^b^a=b;
//原理是：^1会取反  ^0会不变	所以^1^1会不变，^0^0也会不变，所以重复^一个数会不变
```

8.

<img src="算法入门一\位运算基础.png" style="zoom:50%;" />

细细品。

## 五、贪心

贪心算法：对问题求解时，总是做出在当前看来是最好的选择，贪心其实是一种寻找最优解的思维，得多练才能理解。

贪心算法关键在于贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

##### **1**.引入题目1：<img src="算法入门一\排队接水.png" style="zoom:50%;" />

比较基础的题：列一下就好了,T总=(n-1)T1+(n-2)T2+(n-3)T3+..+Tn，易得接水越快的人站越前面就越好，这也符合我们的常识。

##### 2.引入题目2：<img src="算法入门一\连数问题.png" style="zoom:50%;" />

其实就是在找规律了，这题一开始大家会找到的规律是：按照字典序去作比较，即逐位比较大小，如ab>a>ba>bb;但是其实是有反例的：如3，31,39	39331>39313。

所以这里的主要思想是，将相同331和313直接连起来比较，然后用比较大的那个就行了。

题址：https://ac.nowcoder.com/acm/problem/16783

```c++
#include<bits/stdc++.h>
using namespace std;
string a[100];
bool cmp(string a,string b)
{
    int len=min(a.size(),b.size());
    if(a.substr(0,len)==b.substr(0,len)){
        string t=a;
        a.append(b);//关键
        b.append(a);//的处理
        return a>b;
    }
    else    return a>b;
}
int main()
{
    int n;cin>>n;
    for(int i=1;i<=n;i++)    cin>>a[i];
    sort(a+1,a+n+1,cmp);
    string b="";
    for(int i=1;i<=n;i++)    b=b+a[i];
    cout<<b<<endl;
}
```



##### 3.引入题目3：<img src="算法入门一\区间覆盖(工作安排).png" style="zoom:50%;" />



这里主要需要解决的是，如何选取区间：选取结束时间最早的区间。

选取结束时间越早的，后续的子区间就可能更多，这就是当下最优解延伸出的全局最优解。

题址：https://ac.nowcoder.com/acm/problem/24867

##### 4.引入题目4(高精度乘除法)：

<img src="算法入门一\国王游戏1.png" style="zoom:50%;" />							     <img src="D:算法入门一\国王游戏2.png" style="zoom:50.5%;" />

题址：https://ac.nowcoder.com/acm/problem/16561

找最优解：

1.A在B前：A：sum/RA ① 	B:(sum+LA)/RB ② 	2.B在A前：A：(sum+LB)/RA ③ 	B:sum/RB ④ 

现在解决子问题：\_AB\_比较符合要求还是\_BA\_比较符合要求

开始假设：如果\_AB\_比较好,则会满足max(①,②)<=max(③,④)	（因为你希望AB两者之间拿的多的那个人要拿的尽量少一点，防止别人眼红）

从式子上看，① <③,②>④,这是既定事实，所以只要③>②,则上述假设成立。

代入式子化简就得出：③>②的本质是RBLB>RALA，**所以两只手的数字乘积越小的人应该站越前面。**

**具体的实现：**

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
struct People{
    int l,r;
}p[maxn];//将大臣左右手连接
bool cmp(People a,People b){
    return a.l*a.r<b.l*b.r;
}
vector<int>div(vector<int>a,int b)//大数除法，a/b
{
    vector<int>c;//临时vector容器
    int  x=0,ans=0;//x表示上一次除法留下来的余数
    bool flag=false;
   for(int i=0;i<a.size();i++){//从最高位开始除
       int t=x*10+a[i];//将上次留下来的余数*10+这次的数再除以b
       ans=t/b;//得到的商
       if(ans||flag){	//前置0不录入
           flag=true;
           c.push_back(ans);
       }
       x=t%b;
   }
    return c;
}
vector<int>compare(vector<int>a,vector<int>b)//大数比较，返回大的数
{
    if(a.size()>b.size())    return a;//先比长度
    if(a.size()<b.size())    return b;
    if(a>b)    return a;//长度相同再按字符序逐个比较
    else    return b;
}
vector<int>mul(vector<int>a,int b)//大数乘法,a*b
{
    vector<int>c;//临时vector容器
    int t=0;
    for(int i=a.size()-1;i>=0;i--)//从个位开始乘
    {
        t+=a[i]*b;//记下结果
        c.push_back(t%10);//结果的最后一位数固定下来了，放入容器
        t/=10;
    }
    while(t){//处理剩下的
        c.push_back(t%10);
        t/=10;
    }
    reverse(c.begin(),c.end());//将c翻转的数才是最终结果的数
    return c;
}
int main()
{
   int n;cin>>n;
   for(int i=0;i<=n;i++)
       cin>>p[i].l>>p[i].r;
    sort(p+1,p+n+1,cmp);//按草稿纸上得出来的排序方式排序
    vector<int>sum(1,1);//前面所有人左手的乘积
    vector<int>ma(1,0);//拿钱最多的人所拿的钱
    for(int i=0;i<=n;i++)
    {
        if(i)   ma=compare(ma,div(sum,p[i].r));//利用大数除法计算奖赏并找最高奖赏的人
        sum=mul(sum,p[i].l);//乘上这位大臣的左手数字得到左手乘积
    }
    for(int i=0;i<ma.size();i++)
        cout<<ma[i];
    cout<<endl;
}
```

##### 5.引入题目5：<img src="算法入门一\巨石滚滚.png" alt="巨石滚滚" style="zoom:50%;" />

**这道题贴出来是因为对应的贪心的策略真的挺神奇的**

**贪心策略：**
1.将表现为恢复的障碍物放前头，表现为扣血的障碍物放后头，是为了能有更好的状态面对障碍物。
2.前头的具体排序：由于每一个障碍物都表现为恢复，同样是为了能有更好的状态面对障碍物，所以a大的放后头。
3.后头的具体排序：
思路历程：
①：一直在扣血，那么将a大的放前面尽早解决，先啃硬骨头。（忽略了b带来的影响）
否定：啃完恢复的少了，那没那么硬的骨头你也啃不掉了。
`7 1`
`5 3`如果有10滴血，打完后者能打前者，打完前者打不了后者了。

②：保留最好的状态去打下一个人，即把扣的血`a-b`少的放前面。
否定：关键不仅在于有更好的状态，而且还要能打赢下一个a。（忽略了a带来的影响）
`1 0`扣的血：-1.
`7 5`扣的血：-2.如果有7滴血，打完前者打不了后者了，打完后者还能打前者。

**将思路放到能不能打赢的边界，即AB能打赢，BA就打不赢了。**

**设立a1 b1,a2 b2，如果AB能打赢，BA就打不赢了，那么会满足：AB受到的伤害<BA受到的伤害，即公式：a1-b1+a2<a2-b2+a1**

**化简为：b1>b2**

**将b大的放前头，才能不死，这就是当下最优解延伸出的全局最优解。**



## 六、总结

​	内容还是蛮多的，主要是入门的一些算法思想，其实大多好像也只是数学思想罢了，当然需要掌握也不是一蹴而就，主要是有所了解了。