---
title: 面试基础知识合集
date: 2024-01-06 16:30:00
tags: 前端
---

**一些校招时准备的八股文**

<!--more-->

## 一、网络基础

### TCP三次握手

**普通版**：

让双方都确认自己可收发。第一次握手，服务端确认自己能收到客户端的请求(能收)；第二次握手，客户端确认自己发送的请求服务端能收到(能发) && 自己能收到服务器的请求(能收)；第三次握手，服务端确认自己发送的响应客户端能收到(能发)，至此，完成确认。

**高手版**：

握手的目的主要是<u>初始化连接序列号</u>，三次是<u>避免历史连接被错误建立</u>的最少次数。

初始化序列号：因为网络复杂容易丢包或请求乱序，明确每个包的序列号是信息稳定的核心。

历史连接被错误建立：如果只有两次握手的话，假设客户端有个握手请求走丢了半天后突然打到服务端了，那此时服务端识别到后直接第二次握手完成连接建立，然后开始库库发服务端数据，那不就狠狠浪费带宽了吗，因为这个握手请求并不是客户端最新的握手请求，所以需要第三次握手来确定发送方拿到的初始序列号就是客户端最新的才开始库库发。

### TCP四次挥手

目的与必要性：拆除两条信道并释放资源。

第一次挥手，客户端告诉服务器希望结束连接，表示此后自己不再发送数据了。第二次挥手，服务器告诉客户端它知道要结束连接了，但需要等待服务器将手头的工作处理完。第三次挥手，服务器告诉客户端我处理完了，准备结束连接。第四次挥手，客户端告诉服务器正式结束连接。

TCP有半关闭机制，也就是第二次挥手后客户端就能关闭「客户端->服务端的信道」了，第四次挥手才关闭「服务端->客户端的信道」
关于三次挥手：当服务端被通知关闭并且刚好手头的活都干完的时候，可以把第二次挥手和第三次挥手一起发送，形成三次挥手

### TCP是怎么保证安全传输的

1.检验和。将TCP伪首部、首部与数据部当作16位的数字进行取反再相加，进位补到低位进行再相加（再加上初始检验和0000的反码1111，结果作为新检验和），收到方同样操作，若得不到全为1则传输有误。

2.序列号与确认应答。对发送的数据进行编号，收到方收到后返回ACK报文，告知发送方需要传递的下一数据序列号，发送方以此为准进行发送，若没收到应答包则会重发数据。

3.超时重传机制。发送方发送后一段时间没有收到答复则重发数据。

4.流量控制。TCP流量控制是基于滑动窗口机制的，总的来说就是接收方会返回接收窗口的可用大小，借此保证发送窗口小于等于接收窗口。

5.拥塞控制。TCP拥塞控制主要流程为，慢开始 ==> 到达慢开始门限时改为线性增长(拥塞避免) ==> 发生超时后取当前窗口cwnd大小的一半作为慢开始门限，同时执行慢开始 ==> 需要重传时，慢开始门限设为当前窗口cwnd大小的一半，同时直接以门限为窗口大小执行拥塞避免(快恢复算法)。

### TCP与UDP的区别

TCP是面向连接的，确保可靠、无差错无丢失无重复且按序到达，首部20字节，面向字节流传输，一般用于需要连接或大量数据的传输。

UDP是无连接的，不保证可靠交付，首部8字节，面向报文传输，一般用于需要迅速传递的数据。

### UDP伪首部是什么

首先UDP的首部是8字节的，包含源端口、目标端口，长度与检验和，而伪首部是12字节的，包含源IP、目标IP、0、传输协议号(TCP是6，UDP是17)、UDP总体长度(首部+数据)；伪首部会自动生成（根据IP报文生成）然后填充到首部，用于生成检验和，生成之后又去掉伪首部，这样做的目的是在传输层二次检查IP的正确性。

### HTTP的各个版本介绍与区别

Http1.1相对于1.0的升级，1.增加了Host的头处理，Http1.0时期是默认一个IP对应一台服务器，随着虚拟主机的出现，就需要传递Hostname属性了；2.增加了长连接，具体表示是Connection属性的keep-alive，建立长连接可以减少经常建立与关闭连接带来的消耗。

Http2.0相对于1.1的升级，1.使用二进制格式传输，相较于之前的文本传输更快。2.会对Header进行压缩，并配有header cache可以缓存Header，减少了Header的重复传输。3.多路复用(连接共享)，即多个请求可以在同一个连接里并行执行。4.服务器推送，比如访问index.html的时候会将index.css，index.js都主动发送过来，要用的时候直接在缓存里拿就可以了，减少了二次请求。

Http3.0的话还在草案阶段，总的来说就是把底层的TCP替换成UDP，能更快的请求数据，同时也能更好的实现真正的并行传输。

### HTTP1.1的传输

- ‌HTTP1.1其实是串行传输的(同域)，有队头阻塞，之所以有些时候说他是并行的，是因为浏览器方面有管道的概念。
- ‌首先说HTTP1.1为什么是串行的，串行是指必须接到请求A的响应才会发起请求B，原因是当你同时发起请求A与请求B时(非并行非并发，按顺序发，只是指不用等响应就发)，浏览器拿到响应却无法知道是A的响应还是B的响应。
- ‌管道是什么设计呢，其实就是允许你同时发起A和B，但服务器只会先返回A再返回B，这样浏览器就能知道这次拿到的响应是哪个请求的，同时也实现了B不用等到接到响应A再发送。但是即使使用管道，本质还是存在队头阻塞的概念，因为如果B先处理完成，也要等到A处理完成并响应才能响应B。(实际上是否支持管道要看浏览器，而多数浏览器即使支持也是将它作为高级选项，一般情况下是禁用的)
- ‌综上所述，HTTP1.1要实现并发只能通过建立多个TCP连接完成，而浏览器是有限制TCP连接数量的，比如Chrome为6个。

### HTTP2的多路复用

- ‌http2的多路复用可以并行的发送请求与接收响应了。(其实是并发)
- ‌能做到的原因主要是，HTTP2.0的传输是以二进制的形式，同时有帧与流的概念，发起与接收的流内都有帧标识，通过这个帧标识就能知道这个响应是哪个请求的，解决了http1.1中的队头阻塞问题。
- ‌HTTP2.0发起请求也有优化，HTTP1.1中的同时发起请求是按顺序发的(只是不用等响应)，因为是字符串形式，所以服务器只能接受完上一条再接受下一条。而HTTP2.0中不同流的帧可以乱序到达，只要同流下的帧顺序到达即可，这样表现出来就是请求可以并发(宏观并行)。

### HTTP2的缺点

- HTTP的队头阻塞解决了，但TCP层的没解决，TCP有超时重传的机制，丢了一个包，服务端要等客户端再次传这个包才继续接处理下一个包(没接到丢失包前收到的其后面的包应该会放进接收缓存区)。(不过TCP比较可靠不容易丢包，所以还好)
- ‌多路复用是并发的，也就是虽然能宏观并行，但和时间片轮转算法一样，如果一次发起十几个请求，虽然他们都能很快的开始传，但到传送结束的时刻可能因多路复用而拖后导致超时，比如单独发A不超时，单独发B不超时，同时发AB导致俩都超时了。

### HTTP与HTTPS的区别

- HTTP是超文本传输协议，用于从www服务器传送超文本到客户端，而HTTPS则是HTTP+SSL的简称。
- HTTP是无状态的，建立于TCP连接之上，比较简单；HTTPS建立于SSL/TLS连接之上，SSL/TLS连接再建立于TCP之上，允许身份认证和加密传输，安全性更高。
- HTTPS需要ca证书，需要money。
- HTTP的端口是80，HTTPS的端口是443。

### HTTPS与数字证书

- 基本原理
  - 客户端向服务器请求建立SSL连接，服务器发送证书(含公钥)给客户端，客户端建立会话密钥，并用公钥加密，然后发送给服务器，服务器收到后用私钥解密会话密钥，并用会话密钥加密与客户端的通信。
  - 双方传输数据时，用会话密钥对信息进行对称加密(同一把钥匙)，而会话密钥的加密，则用非对称加密(不同的钥匙，一般是公钥加密私钥解密)。

- 服务端给出公钥，此时公钥还没有被加密，也就是可以被窃取，这有危害吗。
  - ‌首先公钥只是拿来加密会话密钥的，不能拿来解密，因此只拿到公钥无法破解会话密钥(因为会话密钥只由客户端加密再传送，也就是说只有有私钥才能破解)，自然也无法看到数据。
  - ‌但还有一种风险，是拦截到服务器给出的公钥，新生成一对公钥私钥，将假公钥穿给客户端，下次再拦截客户端消息时就能用自己的假私钥解密会话密钥，再用真公钥发[假消息]给服务器。
  - 所以真实的情况是，服务端给出的是第三方CA机构颁发的数字证书，数字证书里包含:[网站的信息,包含网站IP、所有者、公钥等]，以及第三方CA机构用自己的私钥加密[网站信息]生成的[数字签名]。
  - 而浏览器会安装第三方机构的公钥，拿到响应之后先用第三方机构的公钥解密数字签名得到CA机构那登记的真实[网站信息]，然后与响应内的[网站信息]进行比对，一样才给通过，不一样就给出风险提示，这样就保证客户端拿到的网站信息与该网站在CA机构登记的网站信息是一致的，规避收到假公钥的风险，然后再拿到[网站信息]里的公钥加密会话密钥。
  - 所以理论上只要CA机构不出错，HTTPS就是安全的；不过这样依赖就显得CA机构权力很大，因此又提出一种CT(证书透明)的解决方案，建立一个日志服务服务器，它会用自己的私钥对CA证书加密生成SCT签名，浏览器用日志服务器提供的公钥进行SCT解密查看证书是否和日志服务器里登记的一致。
  - CT的核心机制就是去中心化，所有CA证书都能在这被看到，然后对所有CA证书的SCT签名维护一棵默克尔树，这样就保证了没有任何一个CA证书能被篡改。而由于CA证书大家都可见了，CA机构们就失去了偷偷发布不合法的CA证书的机会。
  - 这里引申一下HTTPS代理工具的原理，代理工具就类似于第二点中的拦截者的身份，由代理工具和服务器完成TLS握手，然后代理工具又和本地模拟TLS握手（本地安装了代理工具的证书）。

  > CA机构一般是具有一定行业影响力的权威机构，比如微软、谷歌、中国互联网络信息中心，原则上这些机构没有颁发错误CA证书的动机，因为这会给自己的商业信誉带来巨大的负面影响。

## 二、浏览器基础

### 浏览器的进程与线程

**浏览器有4大进程**：

- 主进程：浏览器页面的显示与交互、对各个页面的管理调度、将Render树渲染（渲染进程中的GUI线程）的结果显示到页面上、下载网络资源等。
- 第三方插件进程
- GPU进程：用于3D绘制等。
- 渲染进程（重点）：页面渲染、脚本执行、事件处理等。（我的理解是每加载一个页面就多一个渲染进程）

一个页面被加载的流程：输入url，主进程接管并下载相应的网页资源（DNS、TCP、HTTP(S)），然后通知渲染进程进行页面构建（DOM、CSSObjectModel、Render），期间可能结合GPU进程，渲染完成后将结果共享给主进程，主进程显示页面。

**渲染进程有5大线程**：

- GUI渲染线程：解析HTML、CSS，构建DOM树，Render树，布局与绘制等。
- JS引擎线程：执行JavaScript脚本。
- 事件触发线程：当对应事件被触发时，由该线程负责将回调函数置入任务队列。
- 定时器线程：用于计时的工具人。
- HTTP请求线程：对应XHR建立连接后，检测XHR状态变更，变更后产生状态变更事件。

> JS引擎线程与GPU渲染线程是互斥的，原因是JS可以操作DOM，如果边操作边渲染的话，容易引起频繁的回流重绘，造成资源的浪费。
>
> 那么defer script和async script有改变他们互斥的性质吗？首先常规script标签会阻塞DOM渲染，这就是因为JS引擎线程互斥了GPU渲染线程。
>
> DOM中的动态script标签分为两步，下载script代码与执行script代码。
>
> - 常规script标签是要立即执行的，因此GUI渲染线程要老实等着script下载+执行。
> - defer script会在DOMContentLoaded前再执行，因此GUI渲染线程就没必要等你script下载了，减去了script下载对DOM渲染的阻塞效果，而在DOMContentLoaded调用前，DOM树已经构建完毕，但又没有形成Render树，因此不会引起回流重绘。
> - async script也同样能够减去script下载引起的阻塞效果，但下载完后立刻执行，JS引擎线程一启动，GUI渲染线程依旧被阻塞。

> DOMContentLoaded阶段，DOM树构建完成。
>
> load阶段，Render树渲染完成。

WebWorker的实质是在渲染进程下新建了一个能执行JS的线程，并与JS引擎进程能以postMessage API进行通信。

### 输入网址到页面渲染的全过程

答：DNS域名解析-->建立TCP连接-->建立TLS连接(Https)-->发起HTTP请求-->获取HTTP响应-->构建DOM树-->构建CSSOM树-->合并为渲染树-->布局与绘制。

### 减少回流重绘的手段

当页面元素的几何属性变化的时候会需要重新构建DOM树，这就是回流；而元素的非几何属性变化的时候，引起渲染树重新渲染页面，这就是重绘。

- ‌浏览器本身有优化，修改样式的时候是先入队，积累了一定的操作或到一定时间才去执行修改，避免过于频繁的触发回流，但当你试图使用offsetTop等方式获取布局信息的时候，会强行执行队列的内容以获取最新的布局信息，这一点需要注意一下。
- ‌通过上面的栗子也可以知道，将dom的修改放在一起是一个优化方案，比如通过修改class统一改元素布局。
- 离线更改DOM元素，即先把DOM元素移除(diaplay:none)，修改完之后再加上去，这样只会触发一次回流。
- ‌transform，opacity运用了css硬件加速(单独GPU渲染)，可以多用这些css。

### 配好跨域后，HTTPS可以向HTTP发起ajax请求吗

不行，HTTPS只能请求其他HTTP的资源，这是浏览器的安全限制。

### CSRF与XSS原理

答：XSS攻击（跨域脚本攻击）本质是引诱点击（反射型）、服务器注入（存储型）或输入框（URL注入）等方式，让用户执行相应的脚本，从而达到恶意攻击用户的目的，应对方式有对用户的输入进行过滤，设置HttpOnly等；

CSRF（跨站请求伪造）本质是网站伪造用户的身份去执行用户本身不知情的请求，如用户在A网站登陆，访问B网站的时候，网站诱使用户在B网站上发起对A网站的请求，由于本地浏览器存储了相应的Cookie，则会导致B网站以用户的身份执行了某些操作，应对方式的话有验证HTTP的Referer字段(确认请求来源是否合法，比如同源)，Token验证等。

### Cookie

- Cookie是HTTP无状态的一个解决方案，一个Cookie可能包含：值、expires、Max-Age、path、domain、secure、httpOnly(仅服务端能设置)、sameSite。

- 一般由服务端返回Set-Cookie响应头进行设置，一个Set-Cookie只能设置一个cookie；客户端也能设置，但不允许操作httpOnly的Cookie。

- Cookie分为两种，一种是会话型Cookie，存储在内存中，随窗口关闭而销毁；另一种是持久型Cookie，存储在磁盘中，到期才销毁。（当未设置过期时间`expires或Max-Age`时为会话型Cookie，否则为持久型）（特殊的，Max-Age为负数也是会话型）

  > 部分浏览器可能会还原会话Cookie，让浏览器好像未关闭过一样。

- 跨域的ajax请求如果要带上Cookie，需要设置xhr的`withCredentials: true`，服务器的接口也要设置`Access-Control-Allow-Credentials = true`。

- Cookie的secure属性与httpOnly属性
  - secure为true的时候表示该Cookie会以安全的形式传送往服务器，即只能用HTTPS传
  - httpOnly为true的时候表示该Cookie无法被程序(比如Js脚本)读取，可以防范XSS攻击。

### Session

- Session是基于Cookie的一种保持会话状态的方式，第一次连接时它会将SessionId返回给客户端的Cookie，并在服务器本地建立SessionId的映射关系，之后每次收到SessionId就尝试去映射，如果映射成功代表建立过会话，如用户正处于登录状态。
- 相比于直接在Cookie里传递username和password等状态，通过SessionId保持登录状态显得更为安全。
- 主要缺点：1.占用服务器资源；2.负载均衡时多个服务器不好维护共同的session映射

### Token

- Tokens是可以脱离Cookie的一种保持会话状态的方式，JWT字符串本身分为header、payload、signature三个段，用`.`分隔，并且可以对其加密，并由header和payload生成signature签名以检验正确性（不被篡改）。

- 为什么有了Session还需要JWT
  - 1.节省服务器资源，准确来说就是时间换空间，Session需要在服务器保留SessionId的映射，而且Session面对服务器集群或多点登录时，还需要共享Session映射；而Token本身就是加密过后的信息，发到服务器时服务器进行解密校验，确保Token合法且没过期即可。
  - 2.防范CSRF攻击，Session是基于Cookie的，而访问站点的时候相应的Cookie会被自动带上，而Token则比较自由，可以放请求体里，也可以放请求头的Authoration字段里。

- Token的本质是令牌，客户端不需要识别出Token，也不需要修改Token，只需要老实接收与发送就行了；因为是由服务端对Token进行加密的，所有就只有服务器自己能解密，服务器每次收到Token之后对其进行解密，拿到原样之后依据header里标识的签名生成算法，对header和payload形成签名，看和signature是否一致，一致则说明数据无误；然后直接判断是否过期即可，没过期的话JWT验证就通过。（比如酷狗每日清空登录状态就可以发一个Expires为当天24点的Token做到）

- 一般为了安全性会让Access Token的过期时间尽量短，为了不让用户频繁重新登陆，可以另发一个Refresh Token，Access Token过期了就去看Refresh Token有没有过期，没过期就給它发新的Access Token，Refresh Token都过期了那就只好重新登录了。

- 关于Token存在哪的问题其实没有唯一答案，一种是存在Cookie里+HttpOnly，这样的话就和Session一样需要处理跨域，同时会有CSRF的风险；一种是存在WebStorage里，但会有XSS攻击的风险。但总结来说，我认为的比较安全的方案是：Cookie+HttpOnly+samesite:lax，可以防范CSRF。

- JWT缺点：Token一旦签发了，在到期时间前就一直有效，无法中断。

  > 无论是Session还是Token，你钥匙(SessionId或token)被偷了就是会有被盗号的风险，这没办法。不过一般敏感操作会走二次确认，比如支付时会要你输入支付密码而不是有登录状态就行。

### SameSite

- 首先SameSite是Cookie的一个属性，用于表示Cookie啥时候可以发送。

- Cookie经常会作为网站收集用户行为进行个性化广告推送的方法，同时也会被利用来进行CSRF攻击；Chorome80出手改了Cookie的SameSite默认值，希望以此杜绝CSRF攻击。

- SameSite顾名思义就是同站，同站的概念没同源那么严格，只要两个网站的eTLD+1相同即可，eTLD是由Mozilla 维护的公共后缀列表，也叫有效顶级域名，如`.com、.co.uk、.github.io`等，+1则表示加上二级域名；即`有效顶级域名+二级域名`相同则为同站，如a.taobao.com与b.taobao.com就是同站。

- SameSite有三个值，Strict、Lax与None，以前浏览器给的默认值为None，而最近Chrome80开始已经将默认值设为了Lax。

  > Strict：禁止所有非跨站请求带Cookie，连a标签跳转都不行
  >
  > Lax：仅允许a标签跳转、预加载、get表单跨站，其余post表单、ajax、图片、script标签全都不允许跨站带Cookie。
  >
  > None：允许所有跨站请求带Cookie，但Chorme新版本设置为None的前提是Cookie添加Secure属性。

### Cookie、Session与WebStorage的区别

Cookie一般保留在客户端，会随着HTTP请求发送至服务器，存储Cookie时一般会设置过期时间，同时Cookie的大小最大只能为4KB，以字符串的形式存储，有不安全、浪费带宽这些缺点

Session一般保留在服务端，大小没有限制，通过Key-Value的形式存储，相对于Cookie会安全一些，有依赖于Cookie、占用服务器资源等问题。

SessionStorage和LocalStorage同属于Web Storage机制，是HTML5中对于Cookie机制的改进机制。Web Storage存储容量为5M，不用随请求发送至服务器，因而相对安全且不浪费带宽，且数据操作也简单一些`setItem(key,value)`，SessionStorage随着浏览器窗口关闭而失效，LocalStorage理论上只要不主动清除就一直有效。

### 浏览器缓存

强缓存就是在规定时间内都用浏览器的本地缓存去展示页面，返回值为200

协商缓存就是向服务器发起请求，根据etag与last-modified判断资源是否发生变化，发生变化则返回新资源与200状态码，没发生变化则返回304状态码示意使用浏览器缓存。

#### a.强缓存（Expires、Cache-Control）

> 收到服务器响应时，若响应头检验到强缓存相关字段，则将资源缓存至Memory Cache或Disk Cache，此后对该接口的请求，若检验到本地有缓存且有效则从缓存中取，并返回缓存数据与200状态码。

HTTP1.0有Expires，定义固定过期时间；HTTP1.1后定义Cache-Control，拓展了缓存的配置，其中的Max-age的相对时间解决了客户端机器时间不一致引起的问题。（Cache-Control优先级更高）

上述同时存在时，Max-age会覆盖Expires。

> **Cache-Control字段**
>
> Public/Private：表示是否允许代理服务器缓存。
>
> no-cache：仅开启协商缓存。
>
> no-store：强缓存/协商缓存都不开。
>
> max-age：缓存保质期。

#### b.协商缓存（If-Modified-Since/Last-Modified、If-No-Match/Etag）

> 当响应头携带Last-Modified字段时，下次请求头会将该值添加到If-Modifed-Since字段上。
>
> 当响应头携带Etag字段时，下次请求头会将该值添加到If-No-Match字段上。
>
> 当服务器判断资源未更改时，返回空响应体与304状态码。

Last-Modifed即文件的最后更新时间，缺点是最小单位为1s，且存在文件定期更新但实际内容不变的情况。

Etag即根据文件生成的哈希值，具有唯一性，缺点是服务器生成Etag需要花费时间。

上述同时存在时，都匹配成功才判断为资源未更改。

#### c.缓存区域查找顺序

Memory Cache（tag页关闭就失效，加载相对较快） - > Disk Cache（磁盘） - > Prefetch Cache（link携带prefetch属性时会出现，表示在浏览器空闲时加载）

## 三、前端框架

### 虚拟DOM与diff算法

答：虚拟DOM就是用JS去模拟DOM结构，由于JS的执行速度是比操作真实DOM要快很多的，所以在Vue中，当数据变更时并不会直接操作真实的DOM，而是先构建旧的虚拟DOM与新的虚拟DOM，通过diff算法去计算出变更的信息，然后直接根据变更的信息去操作真实的DOM，从而更新页面。

### diff算法实现细节——Vue2.x为例

答：简单来说的话就是，遍历新老虚拟DOM，每次比较同级的结点，如果标签名和key不相同，则直接删除旧的，换上新的，不再往深度找差异了，如果标签名和key都相同就进行深度比较。

具体讲的话，

1. 构建vnode，主要传入选择器，属性，子节点或元素内文本，构建出具体vnode(sel,data,children,text,elm,key)。
2. patch函数，用于Vnode替换，接受两个参数。若第一个参数为DOM元素，则构建空的vnode并关联该DOM元素；若检测到两个vnode本身不相同(根据key，selector，data判断)，则以新的vnode建立DOM树替换旧DOM树；若相同，则执行patchVnode函数进行深度找差异。
3. patchVnode函数，用于深度找差异。比较vnode是否完全相等，完全相等则结束；否则开始比较结点，一个vnode只能有children或text二选一，若都为children则调用updateChildren函数深度更新，否则以新为准完成替换。
4. updateChildren函数，用于深度更新。首先设置新老结点的头尾共四个指针然后开始循环，每次先让四个指针两两比较，同样初步判断结点本身是否相等，若相等则调用patchVnode函数深度找差异并靠拢指针；若都不相等则在老结点序列里找是否有和新结点头指针指向的结点相同的元素，有的话就深比较，没有的话就新创建，然后新结点头指针往后移。往复循环直到新旧结点的头尾指针其一相遇的时候，将旧指针没遍历到的元素全部销毁，新指针没遍历到的全部新创建。

### 三种不同的diff算法

首先要了解虚拟DOM的结构，姑且称虚拟DOM为vnode，一般vnode含有：key,sel,data,el,text,children几个属性。

#### a.React的Diff算法——递增法

React的Diff算法其实就是遍历新结点列表，以pre[i]维护该结点在旧结点列表中的位置。如果pre[i]<=pre[i-1]，则需要让该旧结点的vnode.el移动到新结点列表中上一结点的后面；如果在旧结点列表中找不到该新结点，就新增结点并插入到新结点列表中上一结点的后面；如果pre[i]>pre[i-1]，则保持结点不变。

在遍历完之后还需要遍历旧结点列表中没被找到过的结点，把它们删除。

除去移动、删除、新增结点的时间复杂度，平均下来是O(n\*m)。

理论上是可以通过Map记录pre[i]，可以将时间复杂度变为O(n)，但官方的回应是：暂时不是很愿意牺牲空间换取这性能优化，必要时会做此优化。

还有一个缺点就是，如果由[3,2,1]变为[1,2,3]，其实只用1,3换位即可，但算法中是将2,3移动到了1后面。

#### b.Vue2.x的Diff算法——双端比较

Vue2.x的Diff算法其实就是设置新旧结点列表的头尾指针，通过让它们靠拢来完成算法。具体流程首先是分别进行头头比较、尾尾比较与两次头尾比较，都不等的话就直接拿新结点去旧结点列表找一遍，还是找不到就新创建。

头头比较相等指针同时往后移，尾尾比较相等指针同时往前移，头尾比较相等则需要移动vnode.el的位置然后指针再各自往中间移；都不等的话拿着新结点去旧结点列表找，找到了就跟头尾比较一样移动vnode.el的位置，并把旧结点列表中被找到的那个结点变为undefined防止后面重复找；都不等且拿着新结点去旧结点列表找不到，则直接新创建结点插入到当下，并且新结点指针往后移一位。

新旧结点任一列表的头尾指针相遇则结束算法，然后将旧结点列表中未遍历到的都删除，新结点列表中未遍历到的都新增。

除去移动、删除、新增结点的时间复杂度，因为存在一直头尾比较不相等的情况，平均下来其实也是O(n\*m)，但如果一直能比较相等的话能做到O(n+m)。

#### c.Vue3.x的Diff算法——前后置预处理+最长递增子序列

Vue3.x的Diff算法借鉴于[inferno](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno)。

首先是前后置预处理，其实就是从头到尾比较一次，从尾到头比较一次，把能对上的都搞定，在这种情况下，比如`Hello World`与`Hea World`可能最后就只需要去处理`llo`与`a`的差异；需要注意的是，j表示从头到尾一直相等的最后下标，preEnd、nextEnd分别表示从尾到头一直相等的，旧结点列表与新结点列表的最前下标，如果j>preEnd了则说明只有新增结点，直接把[j,nextEnd]都新增加入就好了，如果j>nextEnd了，则说明只有删除结点，直接把[j,preEnd]都删除就好了。

如果前后置预处理没完全处理完成，则需要先生成一个suorce数组记录新结点i在旧结点中的位置，如果为-1说明旧结点中不存在该结点（这一点和React的递增法是一样的，差别在于Vue3.x好像做了Map的优化，所以整体是O(n)，具体的话是Map记录新结点对应的下标，遍历旧结点列表，然后查看新结点列表是否有该结点，没有就直接删除，有就为相应source数组赋值）。

注意，Vue3.x是用了遍历去实现生成source数组的，然后在生成source数组的过程中用递增法顺便判断一下是否有需要移动的DOM结点（因为如果不需要，无论是遍历新列表还是旧列表，都应该为递增的），而最长递增子序列是用在了移动DOM结点的优化上，如下。

如果确定了需要移动DOM结点（即source数组不是完全递增的），则基于source生成最长递增子序列（数组形式，记录着source中最长递增子序列的各个元素下标），接着在source上从后往前遍历，是-1就新增加队尾，不在最长递增子序列里就移到队尾，在最长递增子序列里就位置不变。

如果不用移动DOM结点，则把所有source数组值为-1的新结点都新增即可。

最优的情况是只有增加结点与只有删除结点的场景，时间复杂度为O(n+m)，即前后置预处理直接搞定了；而引入最长递增子序列的目的是为了减少移动DOM结点的次数与开销，最长递增子序列本身的生成最快都需要O(nlogn)（贪心+二分，动态规划求的话是O(n^2)），相比于Vue2.x做的变化其实就是用最长递增子序列提高移动DOM结点的效率。

参考：[React、Vue2、Vue3的三种Diff算法 - 掘金 (juejin.cn)](https://juejin.cn/post/6919376064833667080?share_token=bc3ef82a-c749-43ff-9654-17c246ff02aa)

### key在diff算法中的作用

首先key的定义是希望作为列表渲染中的唯一标识，在Diff算法中，如果key相同则考虑深度比较与替换DOM的子内容，如果key不同的话会将整个DOM进行替换。

基于唯一性的key有两个作用：

1.提升Diff算法速度

有了key做唯一标识，那利用key做map映射后，就能轻易知道新旧列表有没有这个结点了。例如如何判断该结点是否为新增结点，没有key时需要遍历一遍旧结点列表，有key了直接O(1)查看map映射就好了。

2.提升Diff算法准确性

既然key标识了唯一元素，那在删除列表中的指定项时，Diff算法能精确的知道是删了哪一项，从而做出准确的更新。

> 如果无法保证key的唯一性，那key的设置就无法起到上述的作用。
>
> 例如，以index作为key，由于当key相同时会对该DOM结点进行深度比较与替换，而不会删除或移动该DOM本身，也就是我们所说的就地复用，所以假设你删除了6项列表的第4项，其实是用了新第4项的内容去覆盖了旧第4项的内容，新第5项去覆盖了旧第5项的内容，最后删除旧结点列表的第6项。此时如果原第4项的组件有个被选中的状态，这个状态依旧会留给新第4项，因为第4项这个组件就地复用了。

> 在就地复用依旧不影响结果的情况下，表现上其实可能会比有唯一key更快，因为就地复用省去了操作DOM结点的开销。

### Vue和React的相同点与不同点

相同点：

- 数据驱动视图
- 虚拟DOM
- 组件化思想

不同点：

- React是JSX+inline style，all in JavaScript；Vue基于HTML模板文件（template、script、style）
- React用setState主动触发视图更新；Vue基于Object.definedProperty或Proxy，监听data中所有数据的更新。
- Vue封装了大量常用的API，诸如.number、v-if、v-for、computed、watch、v-model、v-slot等等；React都要自己额外实现。

### Vue中的nextTick是什么，底层是怎么实现的？

Vue的nextTick算是一个推迟执行函数，它会将对应的回调函数推迟到DOM更新后再执行；原理的话，Vue在内部尝试使用原生的Promise.then或MutationObserver观察者去执行回调任务，前者是微任务，后者会监听DOM的变化，若宿主环境都不支持，则会采用setTimeout方法代替。

### Vue2和Vue3的区别

- 响应式原理，由Object.definedProperty换到Proxy，提升了性能。
  - Vue2采用的是Object.defineProperty() + 数组方法重写，Object.defintProperty()除了对简单属性的监控外，对对象的监控需要加上深监控(递归)和简单属性变为复杂属性的监控，同时由于新增属性与删除属性的时候不会更新视图，需要额外使用Vue.delete和Vue.set去监听；对于数组的监控则还需要通过重写数组的方法实现数组的监控，而且只能监听新增与删除的动作，不能监听新增的属性与删除的属性(要用Vue.set)；Vue3采用的方案是ES6的Proxy，Proxy有懒监听机制，只有当用户使用到该数据时才会对该数据进行监听。
- 基于TypeScript重写，对TypeScript有更好的支持性。
- 组合式API，利于代码维护。
- diff算法由`双端比较`改为`最长递增子序列`。关于最长递增子序列的应用，首先是维护一个source数组，每一项表示新节点i在旧结点列表中的位置，如果旧结点列表中不存在该结点则为-1；接着求出source数组的最长递增子序列，对于新节点的每一项，如果该结点属于最长递增子序列的成员则不变，如果不属于但也不为-1则移入队尾，如果为-1则直接新创建结点移入队尾。
- v-if和v-for优先级改变，2.0中v-for优先，3.0中v-if优先。
- 生命周期函数的名字变化。![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51aa6a3fda5f428185fb1739c4fbdbc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)
- template支持多根结点。

### Vuex是怎么安装到Vue中的

插件通常用来为Vue添加全局的功能，具体一般插件会提供install方法给Vue.use()调用，像vuex的install方法会将vuex的初始化函数混入(mixin)到Vue的beforeCreated生命钩子函数中。

所以其实每个组件的beforeCreated都会执行Vuex的初始化函数，只不过会共用一个store，即在new Vue()的时候传入的store。

vuex有state、getters、mutations（commit）、actions（dispatch）、modules五个属性，异步任务要用actions提交。

> Vuex修改state是同步的，那为啥建议用mutation修改state呢，主要原因有两点：1.mutations限制了不允许异步，vuex的state如果异步修改可能会出现问题；2.方便记录每一次state的变化，利于调试。

### Vue双向绑定原理

在Vue的一个组件中，el指向的选择器就是View视图的渲染区域，new Vue()出来的就是vm实例，即ViewModel，data就是Model；Vue双向绑定其实就是MVVM框架的应用，利用ViewModel观察View和Model，一方更新了就通知另一方随之更新。

具体我们常说的Vue的双向数据绑定中，数据驱动视图没啥好说的，基于Object.defineProperty或Proxy劫持data属性，改变时让Watcher执行相应的视图更新函数即可；关键是监听视图变化然后改变数据这一点，其实就是在讲v-model这个属性而已，这个其实是针对于受控UI组件的，比如表单元素，在原理实现上，其实就是监听了表单状态改变然后让相应数据改变，只是Vue帮我们封装了这个逻辑而已。

> MVVM是前端的设计思想，而MVC是后端的设计思想，MVVM只对应MVC中的View层。

### React中的setState什么时候是同步执行什么时候是异步执行

React会维护一个isBatchingUpdates的变量，默认为false，对应同步执行，为true时，对应异步执行。

在面对由React引发的事件处理时，setState异步执行，如onClick函数，生命周期钩子函数，因为在调用这些函数时React会把isBatchingUpdates设为true。

在面对其他由addEventListener、setTimeout等非React引起的事件处理时，setState表现为同步。

> 这里说的异步，其实只是表示React是否将state放进更新队列，在事件循环结束统一更新。

例题：

```javascript
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      val: 0,
    };
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 1 次 log

    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 2 次 log

    setTimeout(() => {
      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 3 次 log

      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 4 次 log
    }, 0);
  }

  render() {
    return null;
  }
}
// 非concurrent模式下,0034
```

### React路由小细节

- Route下的exact表示严格匹配
- Switch表示只显示匹配到的第一个路由吗，不加这个的话默认是多匹配的，一般是用Switch套着Route。
- Suspense是为路由加载提供一个缓存的过程，页面正在加载的时候就显示Suspense里的东西。

### React Hooks

#### useState

> const [state, setState] = useState(initialState)

#### useEffect

> useEffect(fn, array)

useEffect相当于类组件中componentDidMount、componentWillUnmount、componentDidUpdate的一个集合

- 如果第二个参数为空数组，useEffect相当于类组件里面componentDidMount。
- 如果不传第二个参数，useEffect 会在初次渲染和每次更新时，都会执行。
- 如果useEffect 返回一个函数，React 将会在执行清除操作时调用它。

第二个参数传非空数组的话，表示只有这些元素之一变化才会触发useEffect。

对于函数式组件来说，其实每次尝试重新渲染都会执行一次这个函数，就像类组件每次渲染会执行render函数一样，那么直接把语句写在这个函数中和写在useEffect有啥区别呢？

我的理解是，useEffect是能做到监听这些值有没有变化再去决定是否执行回调，而如果直接把语句写在这个函数里的话，每次尝试重新渲染都会执行，比如更改后的state的值没有发生变化，那useEffect中的回调就不会执行，而直接写在这个函数里的语句则不一定。

#### useContext

> const value = useContext(MyContext);
>
> MyContext即Context对象，返回的value表示Context.Provide提供的值。

总结来说就是Provider直接对应useContext

```javascript
import React, { useContext } from "react";
const UserContext = React.createContext();
export default function App() {
  return (
    <UserContext.Provider value={{ id: 1, name: "z3" }}>
      <User></User>
    </UserContext.Provider>
  );
}
function User() {
  const user = useContext(UserContext);
  return (
    <div>
      ID:{user.id},Name:{user.name}
    </div>
  );
}
```

#### useReducer

> const [state, dispatch] = useReducer(reducer, initialArg, init)
>
> 很像具有封装性的useState，它接收一个形如 `(state, action) => newState` 的 reducer，并返回当前的 state 以及与其配套的 `dispatch` 方法。

```javascript
import React, { useState, useReducer } from "react";
// 子组件
export default function App() {
  function reducer(state, action) {
    switch (action.type) {
      case "up":
        return { ...state, count: state.count + 1 };
      case "down":
        return { ...state, count: state.count - 1 };
      default:
        return state;
    }
  }
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  return (
    <>
      <div>当前计数：{state.count}</div>
      <button onClick={() => dispatch({ type: "up" })}>+1</button>
      <button onClick={() => dispatch({ type: "down" })}>-1</button>
    </>
  );
}
```

#### useCallback

> **const** memoizedCallback = **useCallback**( () => { **doSomething**(a, b); }, [a, b], );
>
> 把内联回调函数及依赖项数组作为参数传入 `useCallback`，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。
>
> 说大白话就是，缓存了回调函数。

触发组件重新渲染一般有三种情况：

- 组件自身的状态改变
- 组件的父组件状态改变，但传给此组件的props没变，这种情况可以用React.memo声明该组件为不受控组件完成优化。
- 组件的父组件状态改变，传给组件的props也变化了，这种情况理论上就是需要更新该组件的。

如果父组件给该组件绑定了一个事件函数，在父组件重新渲染的时候，这个函数会进行一次重新声明，由于函数是引用类型，所以实质上给该组件的props是变化了的，这种情况下即使使用了React.memo也依旧会引起该组件的重新渲染。

针对上述情况，绑定函数实际上还是那个函数，只是进行了一次重新声明，却还是引起了子组件的变化，此时则可以用useCallback包裹该函数，返回该回调函数的 memoized 版本，这个memoizedCallback只有在依赖项有变化的时候才更新。

```javascript
import React, { useState, useCallback, useEffect } from "react";
const Childs = React.memo(Child); // 这个要写外面
export default function App() {
  let [title, setTitle] = useState("这是原始标题");
  const callback = useCallback(() => {
    console.log("嘻嘻");
  }, []);
  return (
    <>
      <div>标题：{title}</div>
      <button onClick={() => setTitle("标题变了")}>改变标题</button>
      <Childs onClick={callback} name="z3"></Childs>
    </>
  );
}
function Child() {
  useEffect(() => {
    console.log("子组件被触发更新了");
  });
  return <>Child</>;
}
```

#### useMemo

> const cacheSomething = useMemo(create,deps)
>
> `create`：第一个参数为一个函数，函数的返回值作为缓存值。
>
> `deps`： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。
>
> useMemo与useCallback，差别在于后者是缓存函数本身，而useMemo则是缓存一个值。

useMemo的经典应用场景：

- 给子组件的传参是引用类型但相对固定，那每次父组件渲染都会引起子组件渲染，这一点合useCallback时提到的案例很像。
- 给子组件的传参或内容的渲染需要基于一定的计算得出，有时候计算结果并没有变化，但重新渲染时依旧要进行此计算，通过将计算结果缓存起来并只有在某些影响计算结果的变量改变时才重新计算，能达到优化的效果。

```javascript
import React, { useState, useMemo } from "react";

export default function App() {
  let [title, setTitle] = useState("这是原始标题");
  let [count, setCount] = useState(1000);
  const caculate = () => {
    let result = 0;
    for (let i = 0; i < count; i++) result += i;
    console.log("计算完成");
    return result;
  };
  const result = useMemo(() => caculate(), [count]);
  return (
    <>
      <div>标题：{title}</div>
      <div>计算结果: {result}</div>
      <button onClick={() => setTitle("更改后的标题")}>更改标题</button>
      <button onClick={() => setCount(9999)}>将计算次数改为9999</button>
    </>
  );
}
```

#### useRef

> const refContainer = useRef(initialValue)
>
> `useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数（`initialValue`）
>
> tips：返回的 ref 对象在组件的整个生命周期内保持不变，因此是可以做缓存效果的

```javascript
// 一般的使用方式
const divRef = useRef();
<div ref={divRef}></div>;
```

## 四、JavaScript基础

### JS垃圾回收机制

答：当内存中的某一块区域没有被任何变量强引用，那么垃圾回收机制就会将它清除；浏览器的具体跟踪方式有两种典型，一种是标记删除，被引用到的就√，然后把没有√的都销毁，缺点是花时长，每次要重新标记一遍；另一种是引用计数，记录有多少个变量在引用这块区域，每次更新的时候改变一下计数即可，缺点是无法处理循环引用。

### 变量提升与函数提升的顺序

变量提升高于函数提升，因此同名函数与变量在预编译时，打印会为声明的函数，因为后覆盖前。

```javascript
console.log(a); // ƒ a(){}
var a = 1;
function a() {}
console.log(a); // 1 变量赋值后覆盖提升的函数
// 另外需要注意的时赋值式函数(var a = funtion(){})不能提前调用(因为只是一个undefined),而声明式可以
```

### WeakMap的应用

答：WeakMap的key只能是对象类型，并且是弱引用的，应用场景的话多用于防止内存泄漏(如下)，也可以用于设置私有属性(因为WeakMap具有无法查看key值的特点)。

```javascript
// 点击btn按钮让count++
let btn = document.querySelector("#btn");
let wm = new WeakMap();
wm.set(btn, {
  count: 0,
  buttonClick: function () {
    let data = wm.get(btn);
    data.count += 1;
    console.log(data.count);
  },
});
btn.addEventListener("click", wm.get(btn).buttonClick);
//这个时候我清除btn元素,就能将与btn元素相关的事件与变量都释放资源,防止内存泄漏
```

### 箭头函数指向

其实知道取决于定义时的上下文，但带入实际场景还是有些不确定。

```javascript
const obj = {
  foo: "foo1",
  bar1: function () {
    console.log(this.foo);
  },
  bar2: function () {
    var xx = () => {
      console.log(this.foo);
    };
    xx();
  },
  bar3: () => {
    console.log(this.foo);
  },
};
obj.bar1();
obj.bar2();
obj.bar3();
let foo = "11";
obj.bar3();
// foo1,foo1,undefined,undefined
// bar2的this指向父级functio的this,父级function的this取决于调用者
// bar3的this指向全局this,由于let不挂在window上,所以依旧是undefined
```

### 严格模式下的this指向问题

首先明确严格模式下的三点：1.全局作用域的this指向window；2.函数作用域的this指向undefined；3.对象调用的函数的this指向调用的实例。

接着看下面：

```javascript
var num = 117;
function func1() {
  console.log(this.num); // 这里没有被严格模式限制,因此自然的指向window.num
}
(function () {
  "use strict"; // 仅作用于函数内
  func1(); // 117
})();
("use strict"); // "use strict"只有声明在函数或脚本顶部才有效,这里是无效的
function func2() {
  console.log(this.num);
}
setTimeout(function () {
  // setTimeout实际上是window在调用,所以callback的this永远指向window
  func2.call(this); // 117
}, 0);
```

### 注意Promise中then的核心

```javascript
console.log("script start");

setTimeout(function () {
  console.log("setTimeout");
}, 0);

Promise.resolve()
  .then(function () {
    console.log("promise1");
  })
  .then(function () {
    console.log("promise2");
  })
  .then(function () {
    console.log("promise3");
  })
  .then(function () {
    console.log("promise4");
  });

console.log("script end");

// promise1,2,3,4都会在setTimeout前执行
// 因为then的微任务不是异步声明的,所以当然是要执行完所有的微任务才轮到宏任务
```

### 原型与原型链

js的所有实例都有一个叫\_\_proto\_\_的属性，称之为隐式原型；而所有的函数（构造函数）都有一个叫prototype的属性，称之为显示原型。每个实例的\_\_proto\_\_都指向其构造函数的prototype，这个被指向的对象就被称为原型对象；实例上找不到的方法会去它的原型身上找，以此反复直到原型为null，这就是原型链。

> JavaScript万物皆对象，因为数字也依旧能调用toString()方法，这是因为数字的原型对象是Number，而Number的原型对象是Object。
>
> 不过基础类型们本身当然不是对象类型的，只是如果调用其方法的时候，比如a.toString()，JavaScript底层会调用相应构造函数(如Number)短暂的创建一个对象实例，然后用这个实例对象去调用toString()，最后将结果值作为此次操作的结果。

### ES5 Class

我们先看一道题

```javascript
class Test {
  a() {
    console.log(111);
  }
  b = () => {
    console.log(111);
  };
  c = function () {
    console.log(111);
  };
  d = 1;
  constructor() {
    this.e = () => {};
    this.f = function () {};
  }
}
// 在看这道题前，我们需要前置了解原型与原型链、手写instanceof、手写new、手写继承
// 分析出来上面其实等价于
function Test() {
  this.b = () => {
    console.log(111);
  };
  this.c = function () {
    console.log(111);
  };
  this.d = 1;
  this.e = () => {};
  this.f = function () {};
}
Test.prototype.a = function () {
  console.log(111);
};

const t1 = new Test();
const t2 = new Test();

console.log(t1.a === t2.a); // true
console.log(t1.b === t2.b); // false
console.log(t1.c === t2.c); // false
console.log(t1.d === t2.d); // true
console.log(t1.e === t2.e); // false
console.log(t1.f === t2.f); // false
```

### typeof 一个类会返回啥

ES5中没有类的概念，类的实例化都是借由new + 函数完成的，如 `new Person()`。

这里的Person()就是构造函数，而class声明类后，也是以 `new Person()` 的方式实例化类的，所以Class本质上应该也是函数才对。

### 对象的结构赋值

```javascript
const obj = Object.create({ x: 0 }); // {x:0}作为obj的原型对象
obj.a = 1;
obj.b = 2;
obj.c = 3;
const { a, ...other } = obj;
// a:1
// other:{ b:2,c:3 },即当前对象内除了a的其他属性
```

### JS的私有属性实现

答：私有属性指的是只能通过内部的函数访问。

```javascript
/*利用Symbol实现私有属性*/
const Person = (function () {
  const _name = Symbol("name"); // Symbol确保唯一性,即使你控制台能看到,你也无法在js层面从外部获取到这个值
  return class Person {
    constructor(name) {
      this[_name] = name; // 以Symbol属性作为key
    }
    getName() {
      return this[_name];
    }
  };
})();
/*class私有属性提案后*/
class Person {
  #name;
  constructor(name) {
    this.#name = name;
  }
  getName() {
    return this.#name;
  }
}
let person = new Person("z3");
console.log(person.getName()); // 只能通过getName拿到这个属性
```

### ES6 class与ES5手动实现继承的差别

- class有暂存性死区，声明前不能用。
- class内部为严格模式。
- class的成员函数没有原型对象。
- class的类必须用new声明。

### JS遍历对象

![image-20221102193025204](https://webvoobssdl.kugou.com/cac324ffec046aabe0bf66950b346909.png)

### 基于JSON.stringify的深拷贝方式的缺点

**序列化对象：**

- JSON.stringify会忽略undefined、Symbol、Function。
- JSON.stringify遇到NaN与Infinity时，会识别为null。
- JSON.stringify面对Set、Map、RegExp都只能识别为空对象。
- JSON.stringify转换成日期时会成为字符串。
- 无法拷贝数据的原型链。
- 处理不了循环引用的问题。

**序列化数组：**

- 相比序列化对象，undefined、Symbol、Function统一识别为null了，其余保持一致。

**演示：**

```javascript
const set = new Set();
set.add("test");
const map = new Map();
map.set("test", "test");
const regexp = new RegExp("test");
const symbol = Symbol("test");
const normalFunction = function () {};
const arrowFunction = () => {};
const date = new Date("2020-10-11");

const obj = {
  undefined: undefined,
  NaN: NaN,
  Infinity: Infinity,
  set: set,
  map: map,
  regexp: regexp,
  symbol: symbol,
  normalFunction: normalFunction,
  arrowFunction: arrowFunction,
  date: date,
};
//obj.cycle = obj;// 循环引用
console.log(JSON.stringify(obj));
// {"NaN":null,"Infinity":null,"set":{},"map":{},"regexp":{},"date":"2020-10-11T00:00:00.000Z"}

const arr = [
  undefined,
  NaN,
  Infinity,
  set,
  map,
  regexp,
  symbol,
  normalFunction,
  arrowFunction,
  date,
];
console.log(JSON.stringify(arr));
// [null,null,null,{},{},{},null,null,null,"2020-10-11T00:00:00.000Z"]
```

### 完成自定义深拷贝函数

#### a.类型判断

> 判断JS原生对象类型的办法，String.prototype.toString.call(val) === '[object Map]'，对于Set、Date、Array、Symbol、Function、ArrayBuffer等JS原生对象都好使，与val.toString()的差异是不会被原型链中的toString()干扰。

```javascript
const isObject = (val) => {
  // 判断是否是object类型,js的基本类型有:Number,String,Boolean,undeinfed,null,object,Symbol,BigInt
  const type = typeof val;
  return type !== "null" && (type === "object" || type === "function");
};
```

```javascript
const is = {
  // js中其实万物皆对象,所以其实所有Js内置对象都能通过这种方式拿到类型,包括null与undeinfed
  // 基础类型
  Number: (val) => Object.prototype.toString.call(val) === "[object Number]",
  String: (val) => Object.prototype.toString.call(val) === "[object String]",
  Boolean: (val) => Object.prototype.toString.call(val) === "[object Boolean]",
  Undefined: (val) =>
    Object.prototype.toString.call(val) === "[object Undefined]",
  Null: (val) => Object.prototype.toString.call(val) === "[object Null]",
  Object: (val) => Object.prototype.toString.call(val) === "[object Object]",
  Symbol: (val) => Object.prototype.toString.call(val) === "[object Symbol]",
  BigInt: (val) => Object.prototype.toString.call(val) === "[object BigInt]",

  // 拓展类型
  Array: (val) => Object.prototype.toString.call(val) === "[object Array]",
  Function: (val) =>
    Object.prototype.toString.call(val) === "[object Function]",
  Set: (val) => Object.prototype.toString.call(val) === "[object Set]",
  Map: (val) => Object.prototype.toString.call(val) === "[object Map]",
  Date: (val) => Object.prototype.toString.call(val) === "[object Date]",
  RegExp: (val) => Object.prototype.toString.call(val) === "[object RegExp]",
  Promise: (val) => Object.prototype.toString.call(val) === "[object Promise]",
  Error: (val) => Object.prototype.toString.call(val) === "[object Error]",
  ArrayBuffer: (val) =>
    Object.prototype.toString.call(val) === "[object ArrayBuffer]",
};
// 需要注意的是,对于非内置对象的实例,运算的结果是原型链上遇到的第一个内置对象
```

#### b.主函数

```javascript
// 深递归,防循环引用
function deepClone(target, weakMap = new WeakMap()) {
  if (weakMap.get(target)) return weakMap.get(target); // 如果已经递归过这个target,则直接返回
  if (is.Symbol(target)) return Symbol(target.description);
  if (is.Date(target)) return new Date(target);
  if (is.Set(target)) {
    const set = new Set();
    weakMap.set(target, set);
    for (let x of target) set.add(deepClone(x, weakMap));
    return set;
  }
  if (is.Map(target)) {
    const map = new Map();
    weakMap.set(target, map);
    for (let [key, value] of target)
      map.set(deepClone(key, weakMap), deepClone(value, weakMap));
    return map;
  }
  if (is.Function(target)) {
    if (/^function|^\(\)/.test(target.toString())) {
      return new Function(`return ${target.toString()}`)();
    } else {
      return new Function(`return function ${target.toString()}`)();
    }
  }

  // 这一条语句上方是会特殊处理的类型,这一条语句下方是对Object与Array的处理,其余情况都返回自身
  if (!is.Object(target) && !is.Array(target)) return target;

  // 对象与数组的循环引用处理
  const result = new target.constructor(); // 利用其构造函数创建新内容(适用于数组与对象)
  weakMap.set(target, result);

  // 普通对象与数组的处理
  const keys = Reflect.ownKeys(target); // Reflect.ownKeys和Object.keys的区别是,前者多返回了不可枚举的私有属性,而for in则会把原型链的也返回
  for (let key of keys) {
    result[key] = deepClone(target[key], weakMap);
  }
  return result;
}
```

### 其他小细节

1、parseInt

```javascript
['1','2','3'].map(parseInt);//[1,NaN,NaN]
map的参数是(item,index,array),parseInt的第二个参数传0的话，就默认是十进制
```

2、写正则时区分正则调用还是字符串调用

- RegExp的：compile，exec，test。
- 字符串的：search，replace，match。

参考 [RegExp(正则表达式) - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#实例方法)

3、Object.is()与'==='的不同

区别是Object.is()面对+0和-0会返回false，面对俩NaN会判断相同；而'==='相反。（他俩都不会执行类型转换）

4、arr.includes和arr.indexOf的区别

一个返回bool一个返回下标已经不用说了，关键是includes可以识别NaN。

5、Number.MIN_VALUE是最小的正数值而不是最小值

## 五、其他

### 前端优化

1.减少请求数量，比如合并资源、使用字体图标，小图片考虑用Base64格式，使用浏览器缓存，少用CSS的@import，避免用空的src与href，使用懒加载。

2.降低资源大小，比如开启服务器的gzip压缩，考虑使用Webp格式的图片。

3.优化网络连接，比如使用CDN内容分发网络，使用DNS预解析，使用持久链接，使用更快的Http2.0。

4.减少重绘回流，比如尽量别用table布局，能用CSS实现的尽量用CSS实现而不用JS，使用节流防抖。

### HTTP常用请求头

印象比较深刻的有：

```c++
Authorization:  存放身份验证的一些信息，如JWT中存放Token字符串
Connection:  连接类型,如keep-alive持久连接
Cookie:  set-Cookie设置的cookie字符串
Host:  服务器域名与端口号
Cache-Control:  浏览器缓存
    如max-age=xxx,public,immutable表示xxx秒内是强缓存,允许代理服务器缓存,即使刷新也不发起服务器请求
```

### HTML5新特性

语义化标签，如Section，Footer，Header等；canvas画图标签；video视频流标签；WebStorage浏览器缓存方案；一些新表单控件，如email，date等。

### CSS3新属性

border-radius圆角边框；box-shadow盒子阴影；background-size背景图片尺寸；background-origin背景图片从哪里显示；transform的2D变换与3D变换；animation动画与transition过渡效果。

### Webpack 打包构建 AST 以后做了什么

构建完AST后，会根据AST生成相应的能兼容低版本浏览器的代码，同时会从AST中找出该模块的依赖模块，并递归此步骤生成依赖图，再根据依赖图生成代码块chunk并输出到文件系统。

### Webpack的HMR机制

HMR又叫热更新机制，作用就是在不刷新页面的情况下可以完成网页中程序代码的局部替换，底层实现的话我没有深入了解。

### 为什么CSS引用通常放开头，JS通常放结尾

在构建DOM树的同时能构建CSSOM树，双方完成构建后直接合并为渲染树，减少了白屏时间，若放在尾部则可能会引起重绘；JS会阻塞DOM树的构建速度，同时由于JS可能改变DOM树的结构，运行时需要一棵稳定的DOM树。

### rem与em单位的区别，px、rpx、pt和dpr呢

em：1.子元素字体大小使用em是相对于父元素字体大小；2.元素的width等属性使用em是相对于该元素的字体大小。

rem：全部长度都相对于根元素的字体大小。

px：CSS像素，相对单位，如浏览器内元素大小400px，可以通过放大浏览器而让元素填满浏览器，因此是相对单位。

pt：物理像素点，绝对单位，即物理分辨率，取决于硬件。

rpx：微信小程序中能根据屏幕自适应的像素单位，小程序的屏宽固定为750rpx。

dpr：设备像素比 = 设备像素/css像素(逻辑像素) = pt/px，iPhone 6 物理像素为 750 x 1334，理想视口 375 x 667 ，DPR = 2。

有些手机为了显示的更细腻，采用4-9个物理像素去显示1个逻辑像素，即DPR大，所以当你用1px的时候，实际上对应了可能4-9的物理像素。

### 操作系统检测死锁与解除死锁的方法

死锁检测：环路检测。建立资源分配表与进程等待分配表，通过反复查找两张表确认是否形成环路，若形成环路则有死锁；检测到死锁后，逐渐撤销所有死锁进程，

死锁解除：1.剥夺资源，剥夺花费资源数最小的进程，判断死锁是否还存在，以此反复；2.撤销进程，根据进程的运行代价逐渐撤销所有进程，判断死锁是否还存在，以此反复。

### 各排序算法的稳定性

稳定的有插入排序，冒泡排序，归并排序，计数排序，桶排序与基数排序；不稳定的有希尔排序，选择排序，堆排序，快速排序。

### line-height = 2，没有单位，行高是多少？

答：line-height的默认单位是em，即为当前元素字体大小的两倍行高。

### 一个具有10个叶子结点的二叉树，度为2的结点个数为多少

二叉树特性，度为0的结点=度为2的结点+1。

### 局部变量、动态变量分别存在哪

局部变量存在栈内，动态创建的数据存在堆中。

### VLAN是什么，对应了OSI中的哪一层

VLAN又称虚拟局域网，即对应一个广播域，VLAN是二层的虚拟技术，也就是数据链路层，不过实际上各个VLAN的通信要依靠网络层。

### 子绝父相是必须的吗

子绝父相只是让父元素作为子元素绝对定位参考系的其中一种方式，实际上子元素的绝对定位参考系选取是找到最近的、position属性不为static的元素。

### fetch请求属于宏任务吗

宏任务队列由事件触发线程维护，微任务队列由JS引擎线程维护，微任务好像只有Promise、process.nextTick(Node.js)和MutaionObserver这三种， Object.observe已废弃，由Proxy替代。

### IPV4多播地址的IP范围

对应IPV4的D类地址：224.0.0.1 ~ 239.255.255.254。

### CSS的渐进增强方式是啥

其实就是对低版本浏览器做兼容，如

```javascript
.transition { /*渐进增强写法*/
  -webkit-transition: all .5s;
     -moz-transition: all .5s;
       -o-transition: all .5s;
          transition: all .5s;
}
```

### 对行内元素使用float会怎么样

对行内元素使用float会将行内元素的属性变为inline-block，可以设置宽高。

### 属性选择器[class~='val']

如果不加\~字符的话，需要完全匹配class名，加\~的话就能匹配包含val的class名。

> class下是可以有多个类名的，以空格分隔；上述的包含val不是指可以识别到val1，而是能识别包含val的，比如"val test"，加~可以识别到，不加就不行。

### background-size的用法

答：cover缩放到刚好覆盖(短边对齐)，contain缩放到图像刚好完整显示，其余情况第一个为宽第二个为高，只有同时设置宽高才会有可能形成非原比例的缩放，其余情况都是原比例缩放。

### flex:1与flex:auto的差别

`flex:1`其实是`flex:1 1 0%`，`flex:auto`其实是`flex:1 1 auto`。（简单来说，`flex:1`是忽略自身长宽，而`flex:auto`不是）

> flex是flex-group，flex-shrink，flex-basis的缩写。
>
> flex-group：放大系数，默认值为0，当有剩余空间时，按剩余空间 × (元素本身flex-group系数 / 容器的flex-group系数和)分配。
>
> flex-shrink：缩小系数，默认值为1，当占据空间多于容器宽度时，按元素自身宽or高 - 多余空间 × (元素本身权重 / 容器总权重)分配，权重计算：所占宽or高 × flex-shrink缩小系数。
>
> flex-basis：初始长度，默认值为auto，为auto的时候值为元素自身的宽or高，为数值或百分比则代表相应的初始长度。（在flex容器中，它的优先级是高于width的，如果flex-basis为0%，width设为1000都没用）
>
> 现在带入场景：假设容器600px，子元素每个100px。
>
> 如果子元素都设flex:1，则其实是忽略了本身的大小，子元素的最终长度是600 × 1/3 = 200；
>
> 如果子元素都设flex:auto，则其实每个元素的大小是100+300 × 1/3 = 200。

### span标签的padding与margin问题

span标签是行内元素，本身除了设置宽高外无效，设置padding和margin时，top和bottom都无效，left和right就有效，当然line-height也有效。

如果希望设置top和bottom有效，那就得转为块或行内块元素，比如设置display或设为浮动元素(参考15)。

### SVG相比Canvas的优势

SVG是以xml格式解析的，同时是矢量图，因此有：不受分辨率影响，支持事件处理等条件；Canvas是用JavaScript绘图的，同时是位图。

### requestAnimationFrame是什么

答：window.requesetAnimationFrame(callback)其实就是让页面下次渲染的时候执行callback函数(callback里地柜调用window.requesetAnimationFrame以实现动画效果)，相比于setTimeout的动画实现方式，一定程度上节省了CPU性能（因为页面不展示在屏幕上的时候setTimeout依旧在工作），而且整体效果也更好一些，保证了每次渲染只会执行一次动画变更函数(即callback函数)。

### 前端设计模式

1.外观模式，为一组接口提供一个统一的高层接口，参考jQuery，把多个API抽象成一个API。

2.代理模式，比如事件委托，或者用Proxy的时候。

3.工厂模式，集中化的创建对象，传入不同参数创建出不同的对象，感觉DefaultPage模板就是工厂模式。

4.单例模式，一个实例贯穿整个系统时使用（只能有一个实例），比如vuex的store。

5.策略模式，关键词是行为，当多个对象的差别在于行为的时候使用。

6.迭代器模式，这个应该没什么好说，不用关心底层怎么存储，直接支持迭代即可。

7.中介者模式，参考聊天室，统一由聊天中枢发出与接收，然后再给到用户，这样可避免复制的多对多关系。

8.访问者模式，将算法与对象结构分离，一般组件都是访问者模式，即拿到对象实例然后用其方法即可。

9.发布订阅模式，顾名思义，比如DOM事件或EventBus的使用。

### PC扫码登录的实现

1. PC向服务器请求qrCode。

2. 服务器生成qrCode，保存qrCode的相关状态（登录状态，过期时间啥的），返回qrCode给客户端，客户端依据qrCode生成二维码并展示。

3. 手机扫码并点击登录后，将手机的token和设备码发给服务器。

4. 服务器收到并确认无误后，更新qrCode的状态，并生成给pc登录的token（token包含一些用户的信息）。

5. PC通过短轮询、长轮询或WebSocket获取到token，最终完成登录。

   > 短轮询：1s发一次。
   >
   > 长轮询：发请求给服务器，服务器不立即返回结果，而是一直等待，直到超时或状态变化才返回结果。（酷狗的opd就是这么做的）
   >
   > WebSocket：建立ws连接后，服务器主动推送。（由于浏览器兼容之类的问题，目前即使是微信、淘宝的扫码登录都是轮询实现）

### 操作系统中死锁的处理

**预防死锁**：从4个必要条件入手。

- 破坏互斥条件：利用SPOOLing假脱机技术，让操作系统认为该资源是可共享的（就像打印机不阻塞用户请求，但会按序处理）——但为了保持系统安全，有些资源必须是互斥的。
- 破坏不可剥夺条件：进程拿不到某个需要的资源时，需要让出自己手里的资源。
- 破坏请求与保持条件：采用静态分配，每个进程一次拿到需要的所有资源。
- 破坏环路等待条件：采用顺序资源分配，进程只能依靠编号顺序拿资源。

**避免死锁**：银行家算法。

- 在表现上就是遍历Need表，挨个试下把Available尽量给它看能否让它执行完，能的话就让它执行完并回收资源，然后重复此步骤，如果最终能让所有进程执行完，则表示存在安全的执行顺序，允许此次分配

**死锁检测**：判断资源分配图能否完全简化。

- 资源分配图记录着：1.该进程需要哪些指定的资源，多少个；2.该资源被哪些进程需要，需要多少个；整体表现为有向图，只需要判断这个图能否完全简化即可。

  ![293510a776bb4ac996687d2ffae0ef45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp (1536×520) (byteimg.com)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293510a776bb4ac996687d2ffae0ef45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

**死锁解除**：资源剥夺法、撤销进程法。

- 资源剥夺法：剥夺花费资源数最小的进程，判断死锁是否还存在，以此反复。
- 撤销进程法：根据进程的运行代价逐渐撤销所有进程，判断死锁是否还存在，以此反复。

### 多个标签页怎么实现通信

- localStorage，通过监听onStorage事件拿到同域下的其他标签页传过来的值。
- sharedWorker

### 跨域解决方案(8种)

前端层面：

- JSONP

- document.domain + Iframe 跨子域。即a.taobao.com内嵌b.taobao.com，他俩都设置`document.domain = tabao.com `，然后他俩就可以互相拿到对方的变量了，比如a内嵌b，a可以通过iframe.contentWindow.xxx拿到b中的xxx变量，b可以通过window.parent.xxx拿到a中的xxx变量。

- window.name + iframe。window.name在location变化之后依旧保留，比如我在控制台给window.name赋了值，无论我如何更新url，只要还是整个标签页，那window.name的值就一直保留；将这特性用到iframe身上，a内嵌iframe，一开始把src设为a.taobao.com，在第一次load回调中将src再改为b.taobao.com，然后会触发第二次load回调，第二次load回调就可以拿到a.taobao.com里设的window.name值，用 `iframe.contentWindow.name` 拿到。

- postMessage。这是XHR2提供的API，本身就允许跨域，不过API的调用者即是接受者，比如要给iframe页发跨域信息，iframe.contentWindow.postMessage("x",targetOrigin)，然后iframe页的本页用window.onmessage回调监听。

  > postMessage的使用场景，比如用户在淘宝页面希望能知道用户是否有在天猫登录过，那只要在天猫页加一个parent.postMessage(msg,"taobao.com")，然后淘宝页通过iframe加载天猫页，加载后通过onmessage回调函数就能拿到天猫页发过来的msg，这样就达到了跨域通信且共享了登录状态。
  >
  > 发送方要加targetOrigin防止被不可信的网站调用拿到，接收方要对msg.origin进行判断，防止受到不可信网站进行的XSS攻击。

协议层面：

- WebSocket。WebSocket连接后已经没有请求头响应头了，自然没有跨域问题。

后端层面：

- CORS。

代理-抓包层面：

- whistle + SwitchyOmega插件。其实就是在酷狗的方案，针对于开发环境跨域但生产环境不跨域的情况。

代理层面：

- Nginx反向代理。

### TypeScript小细节

- nvm的作用是能自由的切换node版本
- TypeScript接口和抽象类的区别：1.接口所有的方法和属性都是抽象的，不能赋值；而抽象类可以有普通方法。2.抽象类对应继承的概念，接口对应implements的概念。
- TypeScript有一个get和set的用法，不过一般不用
- 在定义函数和类的时候，如果遇到类型不明确的时候就可以考虑用泛型`function func<T>(a: T):T`

### grid布局的一些常用属性

**容器属性：**

- grid-template-column、grid-template-rows，对应列宽的定义与行宽的定义，可以结合repeat()使用，可以使用fr进行比例分配。
- grid-column-gap、grid-row-gap，对应列间距与行间距。
- grid-auto-flow，排列顺序，默认值为row，对应“先行后列”，可以设为column；可以加第二个参数dense，表示尽可能填满空间。
- grid-auto-rows、grid-auto-column，对应隐式栅格的布局，比如grid-template-rows只给了两行的高度，那多出来的行就都是隐式栅格。
- justify-item、align-item，place-item，栅格内部的布局方式，与flex的一致；place-item是复合属性。
- justify-content、align-content，place-content，容器内所有栅格的布局方式；place-content是复合属性。

**项目属性：**

- grid-row-start、grid-row-end：上边框对应的栅格线，下边框对应的栅格线。
- grid-column-start、grid-column-end：左边框对应的栅格线，右边框对应的栅格线。
- align-self，justify-self：对应align-item，表示栅格内部的排列方式。

### 关于setTimeout的时限问题

据Js红宝书所说，setTimeout的时限最低为4ms，小于4ms按4ms算，这么说难道`setTimeout(()=>console.log(0),0);`等价于`setTimeout(()=>console.log(4),4);`吗？抱着这个想法我进行了一些探究。

根据[HTML标准](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout)，时间小于0时按0算，超过5层嵌套后才有最小为4ms的限制；所以理论上4ms的限制是有前提的，实际上的最低时延应该是0ms，不过各个引擎的实现自然也有所不同。

Chorme的实现：

<img src="https://img1.imgtp.com/2022/10/04/J2EpwSQZ.png" style="zoom:67%;" />

可以看到1最先打印，因此在Chrome的视角1和0是一样的，因为1先声明了所以先打印了1，得出结论——谷歌的最低时延是1ms。

> 关于4ms与谷歌1ms的由来，可以看[为什么 setTimeout 有最小时延 4ms ? - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/155752686)

Edege的实现：

<img src="https://img1.imgtp.com/2022/10/04/O0mea8tu.png" style="zoom:67%;" />

可以看到-2最先打印，可见Edge的最低时延是0ms。

### 触底刷新与图片懒加载

首先Client的参考系是窗口，Offset的参考系是父容器。

然后介绍几个API：

- offsetHeight/offsetWidth，元素占位的标准宽高，包括了边框、内边距、内容与滚动条（如果存在），但并不代表实际渲染的宽高，后者用getBoundingClientRect()获取。
- clientHeight/clientWidth，元素内容的可视宽高，也就是内容+内边距，不包含滚动条，并且不显示的区域不算在内。
- scrollHeight/scollWidth，元素内容的宽高，与楼上的差别在于包含了不可视的，比如滑动后隐藏的部分。
- offsetTop，可视区域顶部距离容器(父元素)顶部的距离。
- scrollTop，可视区域顶部距离实际内容顶部的距离，也就是竖直滑动中被隐藏掉的区域的高度。
- getBoundingClientRect()：返回元素相对于视口的一些位置关系(以Object返回)，注意right是元素右边框距离视口左部的距离，bottom是元素底边框距离视口顶部的距离。

触底刷新（document.documentElement）：clientHeight+scrollTop >= offsetHeight

图片懒加载（img）：getBoundingClientRect().top>0 && getBoundingClientRect().top<=window.innerHeight

### 迭代方式下的二叉树前中后序遍历

前序，[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```javascript
function preorderTraversal(root) {
  const ans = [];
  const S = [];
  if (!root) return ans;
  S.push(root);
  while (S.length > 0) {
    // 根左右
    const node = S.pop();
    ans.push(node.val);
    if (node.right) ans.push(node.right);
    if (node.left) ans.push(node.left);
  }
  return ans;
}
```

中序，[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```javascript
function midorderTraversal(root) {
  const ans = [];
  const S = [];
  if (!root) return ans;
  let node = root;
  while (node || S.length > 0) {
    if (node) {
      S.push(node);
      node = node.left;
    } else {
      node = S.pop();
      ans.push(node.val);
      node = node.right;
    }
  }
  return ans;
}
```

后序，[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```javascript
function backorderTraversal(root) {
  const ans = [];
  const S = [];
  if (!root) return ans;
  S.push(root);
  while (S.length > 0) {
    const node = S.pop();
    ans.unshift(node.val);
    if (node.left) S.push(node.left);
    if (node.right) S.push(node.right);
  }
  return ans;
}
```

### Package-lock.json的必要性

> **Package.json用于版本控制的一些符号**
>
> **版本号的格式**：major.minor.patch，即主版本号.次版本号.修补版本号。
>
> **语义版本控制规范**：小功能修补时改动patch，上线新功能时改动minor，可能会对兼容性有比较大的破坏的时候改动major。（只是规范，但不一定都会遵守）
>
> - `~` 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0。
> - `^` 会匹配最新的大版本依赖包，比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0。
> - `*` 安装最新版本的依赖包，比如 \*1.2.3 会匹配 x.x.x。
>
> 有时候为了及时的更新包版本的bugfix但又希望表现上保持一致，会用到 `~` 或 `^`。

场景：A项目引用到了B组件，B组件引用到了C组件，A项目希望完全锁住版本，但B组件却没有此限制，因此一旦C组件更新了，更新前后执行的npm install就会有差异。

因此出现了package-lock.json，当package-lock.json符合package.json的规范，则以package-lock.json为准，否则以package.json为准并更新package-lock.json。

### 前端的换行相关

#### a.一个文本单位

> CJK文本：指中文/日文/韩文

- CJK文本以一个字作为一个文本单位。
- 非CJK文本（包括英文符号）以空格分割识别为一个文本单位，如一个单词。
- 中文标点符号依附于前一个单位，两者将组合被视为同一个文本单位。

#### b.关于word-wrap、overflow-wrap和word-break

首先，word-wrap是由早期微软推出的，如今各大浏览器都兼容，不过W3C觉得这名字不太行，决定将名字改成overflow-wrap，所以其实两者只是一个别名关系，不过考虑到兼容性，一般都会用word-wrap。

**overflow-wrap - 对于一行中只有一个文本单位的情况下，溢出时如何拆分换行**

- normal：不拆分，直接溢出显示。

- break-word：截断。
- anywhere：与break-word大致上表现一致，差异在于当容器的width为min-content的时候，break-word不会考虑截断，而anywhere则会。

**word-break - 溢出时如何拆分换行**

- normal：若该行不止一个文本单位，超出边界的那个单位进行换行；若只有一个文本单位，则溢出显示。
- break-all：无论几个文本单位，直接截断。
- keep-all：可以理解为，只有遇到空格才触发换行。
- break-word：相当于 `word-break: normal` 和 `overflow-wrap: anywhere` 的合。

> CSS3中width的一些新属性：
>
> - width: fill-available，自动填满剩余的空间。这个属性其实是块级元素(div)的默认值，新增这个属性是为了让诸如inline-block的元素也能达到填充的效果。
> - width: fit-content，宽度收缩到刚好合适。这个属性和inline-block很类似，宽度取决于内容。
> - width: min-content，收缩到最小。这个是今天的主角，因为display:'table-cell'在内容宽度大于设定的宽度时就表现为min-content，即宽度取决于容器内的最大不可分割单位，比如table-cell里有一个宽度为100的div和宽度为170的img和宽度为200的长串英文，则宽度就为200。
> - width: max-content，超出容器限制。以容器有无限宽度为假设进行布局，也就是说有可能超出父容器宽度。

#### c.应用场景与解决方案

常见问题：td标签，在遇到内容为非常长的英文字符串时会被强行撑开。

> Table标签 === display:'table'
>
> Tr标签 === display:'table-row'
>
> Td标签 === display:'table-cell'
>
> Table有两种布局
>
> - table-layout：'auto'自动表格布局(默认)，列宽由单元格中没有折行的最宽内容决定，类似于min-content。
> - table-layout：'fixed'固定表格布局，列宽由表格宽度和列宽度决定。

table的默认布局是自动表格布局，td标签具有min-content的天然属性，也就是说如果内部是纯文本的话，面临长串英文时会撑开容器宽度。

解决方案：

- td标签内部再包一个div，然后给这个div `设置宽度` 或 `设置word-wrap:break-word` 或 `设置word-break:break-all`，这样这个div就能限制长串英文的宽度。
- 直接给td标签设置`word-wrap: anywhere` 或 `word-break: break-word`。
- 改变table的布局为固定表格布局，然后给td `设置word-wrap:break-word` 或 `设置word-break:break-all` 。
