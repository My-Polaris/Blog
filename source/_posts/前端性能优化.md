---
title: 性能优化
date: 2026-01-13 18:00:00
tags: 前端
---

**性能优化是一项前端的必备基本技能，无论你是搞C端还是B端，因为网站体验这件事天然的被认为是前端的事**
本文从性能优化出发，讲一下性能优化的思路，再引申至具体的手段与技术介绍：如SSR、SSG、React Native

<!--more-->

## 前情提要

当我们讲到性能优化的时候，可能你会直接噼里啪啦说出一丢方案，这是不对的。应该按照「指标 -> 思路 -> 具体策略」的路径

## 性能优化指标
按加载顺序罗列，🌟表示浏览器标准化指标，performance面板能看到

1. TTFB（time to first byte 首个字节到达）
- 定义：从「发出请求」到「接收到响应数据」的时间，包含：网络请求耗时、DNS解析、TCP握手、SSL建连、服务器处理等
- 核心意义：衡量**网络与服务器响应**能力的核心指标。
- 备注：CSR（客户端渲染）中拉取的是空HTML，所以这一步会快于SSR。

2. FP（first paint 首次绘制）
- 定义：页面首次渲染**任意像素**的时间，即使只有背景色或边框也算渲染了
- 核心意义：衡量纯**白屏**时间

3. FCP（first contentful paint 首次内容绘制）
- 定义：页面首次渲染**有意义内容**的时间，比如文字、图像等
- 核心意义：衡量用户首次看到**有用**信息的时间，比FP更实际。
- 备注：在CSR（客户端渲染）中，加载有意义内容一般需要拉取JS并等JS执行后（比如Vue挂载内容到#app下后），而SSR应用因为是在服务器就渲染完了DOM，所以理论上SSR的FCP会快于CSR的。

4. FMP（first meaningful paint 首次有效绘制）
- 定义：页面首次完成**主要内容**渲染的时间，也就是用户感知**渲染已完成**的时间点。
- 核心意义：衡量**核心内容的加载速度**，比FCP更能反馈页面可用性。
- 备注：无统一标准，因此大部分都是由研发自己打点上报的，比如ks推荐在「主接口响应后」或「Dom Ready的NextTick」上报

5. 🌟LCP（largest contentful paint 页面最大绘制）
- 定义：页面**渲染的最大内容元素**完全渲染的时间点，同样是用户感知**渲染已完成**的时间点。
- 核心意义：衡量**核心内容的加载速度**，比FMP更标准化。
- 备注：CSR场景下LCP卡点大多数在于「数据请求响应速度」和「JS执行耗时」；SSR场景下的LCP卡点大多数在于「HTML解析速度」和「首屏图片或视频的加载耗时」

6. INP（interaction to next paint 每次交互到下次绘制）
- 定义：用户**发起交互到下一次渲染**的时间间隔
- 核心意义：衡量页面**交互动作响应速度**
- 备注：比如点击按钮出来弹窗的速度，输入内容出来下拉框的速度等

7. TTI（time to interaction 可交互时间）
- 定义：页面**完全加载并能响应用户操作**的时间点
- 核心意义：衡量页面是否**已经可用**
- 备注：SSR比较关心的指标，因为SSR只是把HTML渲染出来了，但一些时间绑定啥的还需要等JS执行完

8. 🌟TBT（total blocking time 总阻塞时间）
- 定义： FCP 到 TTI 的时间
- 核心意义：衡量页面从**加载完成**到**已经可用**的时间间隔

9. 🌟CLS（Cumalative Layout Shift 累计布局偏移）
- 定义：页面渲染过程中**元素意外偏移**的程度，偏移分数=位移元素大小✖️位移距离，累加所有元素的偏移分数。
- 核心意义：衡量**页面稳定性**，一定程度反映页面回流重绘的次数，也能作为衡量用户交互体验的指标。
- 备注：比如图片宽高发生变化、系统字体变成自定义字体时大小布局变化等。

## 性能优化思路
我们拆解输入URL到页面访问的路径，优化方向不外乎：
1. 加快网络传输
2. 减小资源体积
3. 优化加载策略

## 性能优化手段
> 以前可能会纠结类似于「拆包不也是减小资源体积吗？」这种问题，但拆包不减小总资源体积，它只是加快首屏加载的策略，所以属于加载策略的一part，而treeshaking是真的把没用到的东西完全扔掉，属于属于减小资源体积的一part
1. 加快网络传输
- 增加服务器带宽
- 使用CDN加速
- 使用HTTP2.0
- 浏览器缓存 —— 强缓存与协商缓存等
- 离线包 —— 让APP提前缓存css、js等资源，这样H5去加载的时候可以直接拿缓存而不用发网络请求

2. 减小资源体积
- 图片转webp格式、图片压缩、图片裁剪
- 字体裁剪
- 启用Gzip压缩 —— 开启gzip请求头后，服务端会返回gzip压缩后的数据
- 工程化代码压缩 —— TreeShaking、terser、注释与调试代码删除等

3. 优化加载策略（首屏加载优化）
- 懒加载
- 按需加载（JS代码拆包）
- 分层加载（先快后好，比如先给看缩略图，再给看高清图，或者给骨架屏）
- 预加载
- SSR、SSG

## 衍生技术的一些解释
- SSR（服务端渲染）：指由服务器渲染好HTML再返回给浏览器，优点是首屏加载快、SEO友好，缺点是服务器压力大、开发调试麻烦。SSR返回的是静态的完整HTML，所以FCP自然快，但要能交互需要等待JS完成事件绑定、状态初始化等动作，这个过程叫Hydrate（水合）。（SSR不代表前后端一定不分离）
- SSG（静态站点生成）：在SSR的基础上，把内容生成丛「请求时生成」改成「构建时生成」，仅适用于内容较固定的场景，比如博客、技术文档、帮助中心等。
- React Native：用React语法，经过一个JS桥接层直接操控客户端原生控件（TextView等），它快在不需要经过Webview一系列的转接，直接与原生控件通信，所以性能更高。